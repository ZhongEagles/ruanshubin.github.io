<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Python网络爬虫--历史天气数据采集]]></title>
    <url>%2FPython%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB--%E5%8E%86%E5%8F%B2%E5%A4%A9%E6%B0%94%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86%2F</url>
    <content type="text"><![CDATA[在很多机器学习应用中，天气数据为重要的辅助特征数据，故本文主要介绍如何利用Python获取历史天气数据。 目标网站数据爬取的目标网站为天气网 编程实现导入相关包123456789import requests # 导入requestsfrom bs4 import BeautifulSoup # 导入bs4中的BeautifulSoupimport osimport reimport csvimport pandas as pdimport numpy as npimport timeimport json 下面以爬取北京市历史天气数据为例进行演示： 获取所有月份URL分析网页源代码可知，所有月份的URL在’tqtongji1’的div中。 实现代码如下： 12345678def get_url(request_url): html = requests.get(request_url).text Soup = BeautifulSoup(html, &apos;lxml&apos;) # 解析文档 all_li = Soup.find(&apos;div&apos;, class_=&apos;tqtongji1&apos;).find_all(&apos;li&apos;) url_list = [] for li in all_li: url_list.append([li.get_text(), li.find(&apos;a&apos;)[&apos;href&apos;]]) return url_list 获取某月份的历史天气数据获取到月份URL后，分析月份的页面源代码可知，历史天气数据在’tqtongji2’的div中。 源代码如下： 12345678910111213141516171819def get_month_weather(request_url, year_number, month_number): # month_url = &apos;http://lishi.tianqi.com/beijing/201712.html&apos; url_list = get_url(request_url) for i in range(len(url_list)-1, -1, -1): year_split = int(url_list[i][0].encode(&apos;utf-8&apos;)[:4]) month_split = int(url_list[i][0].encode(&apos;utf-8&apos;)[7:9]) if year_split == year_number and month_split == month_number: month_url = url_list[i][1] html = requests.get(month_url).text Soup = BeautifulSoup(html, &apos;lxml&apos;) # 解析文档 all_ul = Soup.find(&apos;div&apos;, class_=&apos;tqtongji2&apos;).find_all(&apos;ul&apos;) month_weather = [] for i in range(1, len(all_ul)): ul = all_ul[i] li_list = [] for li in ul.find_all(&apos;li&apos;): li_list.append(li.get_text().encode(&apos;utf-8&apos;)) month_weather.append(li_list) return month_weather 获取某年的历史天气数据将各月份的数据汇总即可得到年历史天气数据。 源代码如下： 1234567891011def get_year_weather(request_url, year_number): year_weather = [] for i in range(12): month_weather = get_month_weather(request_url, year_number, i+1) year_weather.extend(month_weather) print &apos;第%d月天气数据采集完成，望您知悉！&apos;%(i+1) col_name = [&apos;Date&apos;, &apos;Max_Tem&apos;, &apos;Min_Tem&apos;, &apos;Weather&apos;, &apos;Wind&apos;, &apos;Wind_Level&apos;] result_df = pd.DataFrame(year_weather) result_df.columns = col_name # result_df.to_csv(&apos;year_weather.csv&apos;) return result_df 执行’result_df = get_year_weather(request_url, 2017)’，结果如下： 详细代码及说明可点击我的GitHub]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络爬虫--模拟登陆教务处网站]]></title>
    <url>%2FGit%E6%95%99%E7%A8%8B--%E6%9C%AC%E5%9C%B0%E5%BA%93%E6%8F%90%E4%BA%A4%E5%88%B0GitHub%E8%BF%9C%E7%A8%8B%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Git操作安装Git客户端客户端下载地址 Git配置 打开Git Bash，键入以下配置信息。 12git config --global user.name &quot;You Name&quot;git config --global user.email &quot;yourmail@server.com&quot; 初始化本地库 创建本地库文件夹并切换到该文件夹： 12mkdir MyGitcd MyGit 初始化 1git init 提交代码 创建代码文件后，将本地文件添加到Git版本库中： 12git add filenamegit commit -m &quot;First commit&quot; Github配置生成公开密钥 注册GitHub账号后，打开Git Bash，键入以下命令生成公开密钥。 1ssh-keygen -C &apos;yourmail@server.com&apos; -t rsa 一路回车即可以，然后会在C:\Users\你的Windows用户名\目录下出现.ssh文件夹，包含id_rsa和id_rsa.pub两个文件，其中id_rsa.pub即为公开密钥，用Notepad++打开，复制其中内容； GitHub上设置公开密钥回到 GitHub 个人首页，点击 Account Settings -&gt; SSH and GPG key -&gt; New SSH key。title 可以随便取名字，Key 里面添加的内容为 id_rsa.pub 文件内所有的代码，然后点击 Apply 即可。 测试与GitHub是否连接成功 打开Git Bash，键入以下代码： 1ssh -T git@github.com 若返回以下内容，则说明连接成功。 1Hi Your Name! You&apos;ve successfully authenticated, but GitHub does not provide shell access. 推送项目文件至GitHub 打开Git Bash，键入以下代码： 12git remote add origin git@github.com:youusername/MyGit.gitgit push -u origin master 推送成功后，即可在GitHub上看到Push上的项目文件。 若出现以下错误： 1fatal: remote origin already exists. 则执行以下代码后，再执行上述代码即可解决上述问题。 1git remote rm origin]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络爬虫--模拟登陆教务处网站]]></title>
    <url>%2FPython%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB--%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86%E6%95%99%E5%8A%A1%E5%A4%84%E7%BD%91%E7%AB%99%2F</url>
    <content type="text"><![CDATA[本文主要介绍如何利用Python的requests库实现学校教务处网站的模拟登陆。关于教务处网站模拟登陆的典型应用主要有课程格子、超级课程表等，教务处网站形式多种多样，但登陆的基本流程类似，即构建表单-提交表单-实现登陆。本文以我浙的教务处网站为例进行模拟登陆演示。 登陆流程分析首先打开我浙的教务处网站首页，F12打开开发者工具，输入学号、用户名、验证码，点击登陆之后，通过开发者工具可以看到，登陆过程包含3次请求，其中2次为暂时重定向(请求返回值为302代表暂时重定向)。 表单分析点击’Headers’,如下图所示，易得第一次请求为表单提交(POST提交)。 提交的表单如下： 其中username, password, authcode分别为学号、密码和验证码，后面的lt, execution, _eventld为表单隐藏值，表单隐藏值是反爬虫的初级手段，那么如何获取表单隐藏值呢？ 获取表单隐藏值表单隐藏值可以在实际登陆前，通过登陆界面表单填写部分的HTML代码获取，由下图所示： 可以看到，在登陆按钮的HTML源代码部分有3项隐藏的Input，观察name和value值，显然就是第一次请求POST的表单隐藏值。 获取3次请求的网址 第一次请求的网址为固定的，即’https://grs.zju.edu.cn/cas/login?locale=zh_CN&amp;service=http%3A%2F%2Fgrs.zju.edu.cn%2Fallogene%2Fpage%2Fhome.htm%3Flocale=zh_CN&#39;； 按照上述分析构造表单，模拟POST请求，返回的’Response Headers’的Location即为第二次请求的网址； 同样的方式获取第三次请求的网址； 访问第3次请求的网址，即可实现登陆，返回登陆之后的HTML代码。 代码实现(Python2.7)导入相关包12345import requests # 导入requestsimport osfrom bs4 import BeautifulSoup # 导入bs4中的BeautifulSoupimport timefrom PIL import Image 实现第一次请求123456789101112log_url = &apos;https://grs.zju.edu.cn/cas/login?locale=zh_CN&amp;service=http%3A%2F%2Fgrs.zju.edu.cn%2Fallogene%2Fpage%2Fhome.htm%3Flocale=zh_CN&apos;log_headers = &#123;&apos;Accept&apos;:&apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&apos;, &apos;Accept-Encoding&apos;:&apos;gzip, deflate, sdch&apos;, &apos;Accept-Language&apos;:&apos;zh-CN,zh;q=0.8&apos;, &apos;Cache-Control&apos;:&apos;max-age=0&apos;, &apos;Connection&apos;:&apos;keep-alive&apos;, &apos;Host&apos;:&apos;grs.zju.edu.cn&apos;, &apos;Upgrade-Insecure-Requests&apos;:&apos;1&apos;, &apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.221 Safari/537.36 SE 2.X MetaSr 1.0&apos; &#125;session = requests.Session()log_html = session.get(url = log_url, headers = log_headers).text 需要注意的是：在访问的过程中，因为涉及多次请求，一定要通过Session()的方式来保持网站的对话。 log_html为访问教务处网站主页返回的html文档，HTML文档的解析包挺多的，这里我们选用BeautifulSoup来解析返回文档，获取表单隐藏值。 123456log_Soup = BeautifulSoup(log_html, &apos;lxml&apos;)submit_list = log_Soup.find(&apos;li&apos;, class_=&apos;mt10 pl10&apos;).find_all(&apos;input&apos;)item_list = []for input_item in submit_list: item_list.append([input_item[&apos;name&apos;], input_item[&apos;value&apos;]])log_data = dict(item_list) 获取验证码图片，进行验证码识别，验证码识别可以采用OCR方式或者机器学习的方法，这里我们简化一下，直接采用手动输入的方式。 1234567891011121314# 获取验证码auth_jpg_url = &apos;https://grs.zju.edu.cn/cas/Kaptcha.jpg&apos;picture = session.get(url = auth_jpg_url, headers = log_headers).contentauth_jpg = open(&apos;Kaptcha.jpg&apos;, &apos;wb&apos;)auth_jpg.write(picture)auth_jpg.close()# 展示验证码log_img = Image.open(&apos;Kaptcha.jpg&apos;)log_img.show()# 输入验证码authcode = raw_input(&apos;Please input authcode: &apos;)log_data[&apos;authcode&apos;] = authcode 构建好表单后，即可实现第一次请求： 12345678910111213data = &#123;&apos;username&apos;:&apos;******&apos;, &apos;password&apos;:&apos;******&apos;, &apos;authcode&apos;:log_data[&apos;authcode&apos;], &apos;submit&apos;:&apos;&apos;, &apos;lt&apos;:log_data[&apos;lt&apos;], &apos;execution&apos;:log_data[&apos;execution&apos;], &apos;_eventId&apos;:log_data[&apos;_eventId&apos;] &#125; # 实际登陆response = session.post(url = log_url, data = data, headers = log_headers, allow_redirects=False)response_headers = dict(response.headers)cookies = response.cookies.get_dict() # 用于第一次重定向 需要注意保存每一次请求的cookies，以保持登陆状态。 第二次请求123456# 第一次重定向home_first_url = response_headers[&apos;Location&apos;]# session_1 = requests.Session()response_1 = session.get(url = home_first_url, headers = log_headers, cookies = cookies, allow_redirects=False)response_headers_1 = dict(response_1.headers)cookies_1 = response_1.cookies.get_dict() # 用于第二次重定向 第三次请求12345# 第二次重定向home_second_url = response_headers_1[&apos;Location&apos;]response_2 = session.get(url = home_second_url, headers = log_headers, cookies = cookies_1)cookies_2 = response_2.cookies.get_dict()final_html = response_2.text # 登陆之后返回的html文档 至此，大功告成，成功登陆教务处网站。 下面就可以做一些有意思的事情了，比如利用flask封装一个API接口，进而做出课程表查询、考试提醒、成绩查询等各种功能型应用。 详细代码及说明可点击我的GitHub]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python网络爬虫--利用pytesseract进行网站验证码识别]]></title>
    <url>%2FPython%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB--%E5%88%A9%E7%94%A8pytesseract%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%AB%99%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Python-tesseract是一个基于google’s Tesseract-OCR的独立封装包；Python-tesseract功能是识别图片文件中文字，并作为返回参数返回识别结果；Python-tesseract默认支持tiff、bmp格式图片，只有在安装PIL之后，才能支持jpeg、gif、png等其他图片格式。 安装PIL及pytesseract1pip install PIL, pytesseract 安装tesseract-OCR软件 pytesseract实际上调用的是tesseract-OCR的内部函数，故在进行网站验证码识别时，需提前安装好tesseract-OCR软件。 安装包下载安装包地址 安装执行默认安装即可，需要记住安装目录，以便于后面配置环境变量。 配置环境变量控制面板-系统-高级系统设置-环境变量-系统变量 ‘Path’-新建-将tesseract-OCR安装目录添加进去，如’C:\Program Files (x86)\Tesseract-OCR’ cmd打开命令提示符界面，输入： 1tesseract -v 可以看到版本信息。 网站验证码识别在源代码中设置训练数据集的路径修改pytesseract.py，否则会报错： 1pytesseract.pytesseract.TesseractError: (1, &apos;Error opening data file \\Program Files (x86)\\Tesseract-OCR\\eng.traineddata&apos;) 修改部分如下： 12345678910111213# 添加下面这行my_env = &#123;&quot;TESSDATA_PREFIX&quot;:r&quot;C:\Program Files (x86)\Tesseract-OCR\tessdata&quot;&#125;if lang is not None: command += (&apos;-l&apos;, lang)command += shlex.split(config)if extension != &apos;box&apos;: command.append(extension)# 添加参数env = my_envproc = subprocess.Popen(command, env = my_env, stderr=subprocess.PIPE) 测试测试图片如下： 代码如下： 12345from PIL import Imageimport pytesseractimg = Image.open(&apos;7025.jpg&apos;)print (pytesseract.image_to_string(img)) 可以看出，识别结果有误，故需要对图片进行预处理： 123456789101112131415161718192021from PIL import Imageimport pytesseractdef power_img(img_name): image = Image.open(img_name) imgry = image.convert(&apos;L&apos;) imgry.save(&apos;g&apos; + img_name) # 保存灰度图 # 二值化 threshold = 140 table = [] for i in range(256): if i &lt; threshold: table.append(0) else: table.append(1) out = imgry.point(table, &apos;1&apos;) out.save(&apos;b&apos; + img_name) return out img = power_img(&apos;7025.jpg&apos;)print (pytesseract.image_to_string(img)) 处理后的图片如下： 此时，识别结果正确。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>网络爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux教程6--Vim程序编辑器]]></title>
    <url>%2FLinux%E6%95%99%E7%A8%8B6--Vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8%2F</url>
    <content type="text"><![CDATA[本文为Linux系列教程的第1篇，主要讲解主机规划和磁盘分区，参考书籍为鸟哥的Linux私房菜。 vi和vimvi的优点 所有UNIX Like系统均会内置vi文本编辑器； 软件的编辑接口均会主动调用vi； Vim均有程序编辑的能力； 程序简单，编辑速度相当快速。 Vi的使用vi分为3种模式：一般模式、编辑模式、命令行模式；[Esc]键退出编辑模式。 简单执行范例 使用vi进入一般模式； 按下i进入编辑模式，开始编辑文字； 按下[Esc]键回到一般模式； 在一般模式中输入“:wq”保存后离开vi。 按键说明一般模式 移动光标的方法 按键 功能说明 h或左箭头键 光标左移动1个字符 j或向下箭头键 光标下移动1个字符 k或向上箭头键 光标上移动1个字符 l或右箭头键 光标右移动1个字符 组合键：30j 向下30行。 [Ctrl] + [f] 向下移动1页 [Ctrl] + [b] 向上移动1页 [Ctrl] + [d] 向下移动半页 [Ctrl] + [u] 向上移动半页 + 光标移动到非空格符的下一行 - 光标移动到非空格符的上一行 n 向后移动n个字符 数字0或[Home] 移动到行首 $或功能键[End] 移动到行末 H 屏幕最上方1行第一个字符 M 屏幕中间1行第一个字符 L 屏幕最下方1行第一个字符 G 文件的最后1行 nG 移动到文件的第n行（配合:set nu） gg 文件的第1行 n[Enter] 向下移动n行 查找和替换 按键 功能说明 /word 向下查找word的字符串 ?word 向上查找word的字符串 n 重复上一个操作 N 反向上一个操作 :n1,n2s/word1/word2/g n1和n2行之间搜索word1，并替换为word2 :1,$s/word1/word2/g 第1行和最后1行之间搜索word1，并替换为word2。 :1,$s/word1/word2/gc 第1行和最后1行之间搜索word1，并替换为word2，询问确认。 删除、复制与粘贴 按键 功能说明 x 向后删除1个字符 X 向前删除1个字符 nx 连续往后删除n个字符 dd 删除光标所在行 ndd 删除光标向下n行 d1G 删除光标所在行到第1行的数据 dG 删除光标所在行到最后1行的数据 d$ 删除光标所在处到该行最后1个字符 d0 删除光标所在处到该行第1个字符 yy 复制光标所在行 nyy 复制光标所在向下n行 y1G 复制光标所在行到第1行的数据 yG 复制光标所在行到最后1行的数据 y$ 复制光标所在处到该行最后1个字符 y0 复制光标所在处到该行第1个字符 p 光标下1行粘贴 P 光标上1行粘贴 J 光标所在行与下一行合并 u 复原上一个操作 [Ctrl]+r 重做上一个操作 编辑模式 按键 功能说明 i 当前光标所在处插入 I 当前行第一个非空字符处插入 a 当前光标下1个字符 A 当前行最后1个字符处插入 o 当前行下一行插入新行 O 当前行上一行插入新行 r 进入替换模式，当前光标1次 R 进入替换模式，当前光标多次 [Esc] 退出编辑模式 命令行模式 按键 功能说明 :w 保存 :w! 强制保存 :q 离开vi :q! 强制离开 :wq 保存后离开 ZZ 文件不变，不保存离开；文件变化，保存后离开 :w[filename] 另存文件 :r[filename] 读入另一个文件的数据，追加到当前行后面 :n1,n2 w [filename] n1到n2行之间内容保存到某个文件 :! command 暂时离开vi到命令行模式下执行command的显示结果 :set nu 显示行号 :set nonu 取消行号 注意：数字通常代表重复做几次的意思。 Vim的保存文件、恢复与打开时的警告信息vim testvim.txt[Ctrl]+z # 切换到后台；——ls –al # 出现文件的暂存文件Kill -9 %1 # 杀掉上一进程vim testvim.txt # 此时会发生报错 12Swap file &quot;.testvim.txt.swp&quot; already exists![O]pen Read-Only, (E)dit anyway, (R)ecover, (D)elete it, (Q)uit, (A)bort: [O]pen Read-Only，打开此文件成为只读文件； [E]dit anyway，正常方式打开编辑的文件，并不会载入暂存文件； [R]ecover，加载暂存文件的内容，救回来之后需要手动删除暂存文件.testvim.txt.swp； [D]elete it，将暂存文件删除； [Q]uit，离开vim； [A]bort，忽略这个编辑行为。 块选择（Visual Block） 按键 功能说明 V 光标经过的地方反白选择 [Ctrl]+v 块选择 y 将反白的地方复制 d 将反白的地方删除 多文件、多窗口多文件编辑 按键 功能说明 :n 编辑下一个文件 :N 编辑上一个文件 :files 列出当前编辑的所有文件 多窗口编辑 将一个大文件切分成多个窗口查看。 按键 功能说明 :sp [filename] 1.当前文件切分 :sp 2.另外一个文件切分 :sp [filename] [Ctrl]+w+j [Ctrl]+w+下箭头 按住[Ctrl]不松，接着按w，松开后按方向切到下一个文件编辑 [Ctrl]+w+k [Ctrl]+w+上箭头 同上 [Ctrl]+w+q 其实就是:q结束离开 注意：语系编码转换使用iconv命令。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux教程5--文件压缩及打包]]></title>
    <url>%2FLinux%E6%95%99%E7%A8%8B5--%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[本文为Linux系列教程的第1篇，主要讲解主机规划和磁盘分区，参考书籍为鸟哥的Linux私房菜。 zip命令 zip –r myfile.zip ./* 将当前目录下的所有文件和文件夹全部压缩成myfile.zip文件，-r代表递归压缩。 unzip –o –d /home/sunny myfile.zip -o：不提示的情况下覆盖文件； -d：–d /home/sunny指明将文件解压到某目录。 zip –d myfile.zip smart.txt 删除压缩文件中的smart.txt文件。 zip –m myfile.zip ./rpm_info.txt 向压缩文件myfile.zip中添加rpm_info.txt文件。 zip –r filename.zip file1 file2 file3 将file1 file2 file3目录压缩起来。 tar命令 tar: -c：建立压缩档案； -x：解压； -t：查看内容（列出文件）； -r：向压缩归档文件末尾追加文件； -u：更新原压缩包中的文件。 上述5个参数只能选1个。 -f：使用档案名字，该参数是最后一个参数，后面只能接档案名。 例： 1234tar –cf all.tar *.jpg 将所有的.jpg文件打成一个all.tar包，-c产生新的包，-f指定包的文件名。tar –rf all.tar *.gif 将所有的.gif文件增加到all.tar包里面去。 压缩123456tar –cvf jpg.tar *jpg # 仅打包，不压缩tar –czf jpg.tar.gz *.jpg # 将所有.jpg文件打包后，用gzip压缩tar –cjf jpg.tar.bz2 *.jpg # 将所有.jpg文件打包后，用bzip2压缩tar –cjf jpg.tar.Z *.jpg # 将所有.jpg文件打包后，用compress压缩rar a jpg.rar *.jpgzip jpg.zip *.jpg 解压123456tar xvf jpg.tar # 解压tar包tar xzvf jpg.tar.gz # 解压tar.gztar xjvf jpg.tar.bz2 # 解压tar.bz2tar xZvf jpg.tar.Z # 解压tar.Zunrar e jpg.rarunzip jpg.zip]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux教程4--磁盘与文件系统管理]]></title>
    <url>%2FLinux%E6%95%99%E7%A8%8B4--%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[本文为Linux系列教程的第1篇，主要讲解主机规划和磁盘分区，参考书籍为鸟哥的Linux私房菜。 文件系统特性Linux文件系统通常会将文件的权限与属性放置到inode中，实际数据放置到data block中，另外还有一个超级块（super block）记录整个文件系统的整体信息。 super block： 记录此文件系统的整体信息，包括inode与block的总量、使用量、剩余量，以及文件系统的格式与相关信息等； inode: 记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的block号码； block: 实际记录文件的内容，若文件太大时，会占用多个block。假设某个文件的属性和权限数据放置在inode4，而这个inode记录的文件数据实际放置在2-7-13-15这4个block中，此时Linux系统能够据此来排列磁盘的阅读顺序，一次性将4个block内容读取出来，此种数据访问的方式我们称为索引式文件系统（indexed allocation）。与之对应的是FAT模式，它是链式的，每个block号码记录在上一个block中，相当于链表的读取方式，无inode。 碎片整理 需要碎片整理的原因是文件写入的block太过于离散了，此时文件的读取性能将会变得很差所致，这个时候需要通过碎片整理将同一个文件所属的block汇合在一起，这样数据的读取会比较容易，FAT的文件系统需要经常碎片整理一下，而Linux的Ext2文件系统由于是索引式的，基本上不太需要经常进行碎片整理。 Linux的Ex2文件系统（inode）Data block（数据块）在Ext2文件系统中所支持的block大小有1KB、2KB、4KB三种，其文件系统限制如下： Block大小 1KB 2KB 4KB 最大单一文件限制 16GB 256GB 2TB 最大文件系统的容量 2TB 8TB 16TB 原则上，block的大小与数量在格式化完就不能够改变了（除非重新格式化）； 每个block内最多只能够放置一个文件的数据； 如果文件大于block的大小，则1个文件会占用多个block数量； 若文件小于block，则该block的剩余空间就不能够再使用了（磁盘空间会浪费）。 文件系统根据需求合理选择，block大了容易造成磁盘容量浪费，小了的话，大型文件会占用数量较多的block，inode需要记录太多的block，可能导致文件系统不良的读写性能。 inode（inode表格） inode记录的文件数据至少包括： 该文件的访问模式（read/write/excute）; 该文件的所有者与组（owner/group）； 该文件的大小； 该文件创建或状态改变的时间（ctime）； 最近一次读取时间（atime）； 最近修改的时间（mtime）； 定义文件特性的标志（flag），如SetUID等； 该文件真正内容的指向（pointer）； inode的特色： 每个inode大小固定为128Bytes； 每个文件均占用一个inode； 文件系统能够创建的文件数量与inode的数量有关； inode记录一个block需要花费4Bytes。 为记录大量的block，inode记录block号码的区域定义为12个直接、1个间接、1个二级间接、1个三级间接记录区。 inode能够指定多少block呢？下面以1KB的block来说明： 12个直接指向：12*1K=12K； 1个间接指向：（1024/4）*1K=256K； 1个二级间接指向：（1024/4）（1024/4）1K=2562K 同理，1个三级间接指向：2563K 总额：12+256+2562+2563（K）=16GB；与文件系统系统限制一致，此方法不能用于2KB及4KB的block计算中，因为这两者将会受到Ext2文件系统自身的限制，计算结果会不大符合。 superblock（超级块）记录的信息如下： block与inode的总量； 未使用与已使用的inode/block量； block与inode的大小（block：1K/2K/4K，inode：128Bytes）； 文件系统的挂载时间、最后一次写入数据的时间、最后一次检验磁盘（fask）的时间等文件系统相关的信息； -1个validbit数值，若该文件系统已被挂载，则valid bit为0，否则为1。 一般来说， superblock大小为1024Bytes，每个blockGroup都可能含有superblock， 主要作用是防止superblock挂掉。 File System Description（文件系统描述说明）主要描述各个blockGroup的起止block号码。 bitemap（对照表）包括block bitemap及inode bitemap：block bitemap：空或非空；inode bitemap：未使用或正在使用。 以上所有信息，均可通过 dumpe2fs 这个命令来查询： dumpe2fs [-bh] 设备文件名 -b：列出保留为坏道的部分； -h：仅列出superblock的数据，不列出其他区段内容。 df 调出目前挂载的设备 命令行： 1dumpe2fs –h /dev/sda2 返回结果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051dumpe2fs 1.42.9 (28-Dec-2013)Filesystem volume name: &lt;none&gt;Last mounted on: /Filesystem UUID: c08f8c76-c1ea-48fd-8423-a33d6145a329Filesystem magic number: 0xEF53Filesystem revision #: 1 (dynamic)Filesystem features: has_journal ext_attr resize_inode dir_index filetype needs_recovery extent 64bit flex_bg sparse_super large_file huge_file uninit_bg dir_nlink extra_isizeFilesystem flags: signed_directory_hash Default mount options: user_xattr aclFilesystem state: clean # 文件系统没有问题（clean）Errors behavior: ContinueFilesystem OS type: LinuxInode count: 1910080 # inode总数Block count: 7679488 #block总数Reserved block count: 383973Free blocks: 3575247 #还有多少block可用Free inodes: 1705442 #还有多少inode可用First block: 0Block size: 4096 #block大小Fragment size: 4096Group descriptor size: 64Reserved GDT blocks: 1022Blocks per group: 32768Fragments per group: 32768Inodes per group: 8128Inode blocks per group: 508Flex block group size: 16Filesystem created: Thu Oct 19 04:42:40 2017Last mount time: Sun Nov 5 18:34:03 2017Last write time: Sun Nov 5 18:33:56 2017Mount count: 9Maximum mount count: -1Last checked: Mon Oct 30 02:06:59 2017Check interval: 0 (&lt;none&gt;)Lifetime writes: 7521 MBReserved blocks uid: 0 (user root)Reserved blocks gid: 0 (group root)First inode: 11Inode size: 256Required extra isize: 28Desired extra isize: 28Journal inode: 8First orphan inode: 551269Default directory hash: half_md4Directory Hash Seed: 967fd3cc-7cec-4848-a2e0-d40a6742de14Journal backup: inode blocksJournal features: journal_incompat_revoke journal_64bitJournal size: 128M # 日志文件容量Journal length: 32768Journal sequence: 0x00010919Journal start: 1 与目录树的关系 查看文件所占用的inode号码时，可以用ls –i命令处理。 Ext2/Ext3文件的访问与日志文件系统的功能新增文件时，文件系统的行为为： 先确定用户对于欲添加文件的目录是否有w与x的权限，若有的话才能添加； 根据inode bitemap找到没有使用的inode号码，并将新文件的权限/属性写入； 根据block bitemap找到没有使用中的block号码，并将实际的数据写入到block中，且更新inode的block指向数据; 将刚才写入的inode与block数据同步到inode bitemap与block bitemap，并更新superblock的内容。 inode bitemap、block bitemap及superblock的数据经常变动，因此称之为中间数据（meta data），当系统因不明原因中断时，可能造成中间数据的内容与实际数据的存放区域出现不一致的情况。 如果发生上述问题，系统会在重新启动的时候，通过Superblock中的valid bit（是否有挂载）及文件系统的state（clean与否）等状态来判断是否强制进行数据一致性的检查。若有需要检查时，则以e2fsck这支程序进行。 因为检查需要扫描整个文件系统，故非常耗时，日志文件系统应运而生。 其工作模式如下： 预备：当系统写入一个文件时，会先在日志记录块中记录某个文件准备写入的信息； 实际写入：开始写入文件的权限与数据，开始更新meta data的数据； 结束：完成数据与meta data的更新后，在日志记录块中完成该文件的记录。 只要只需扫描问题文件即可，可以快速定位，进而达到快速修复文件系统的目的。 而Ext3与Ext2的区别就在于引入了日志文件系统的功能。 Linux文件系统的操作加载到内存中的文件，如果频繁的写入到硬盘中，效率会非常低，故引入异步处理（asynchronously）的方式。 其运行模式为，若内存中的数据发生更改，此时修改部分数据会被设置为dirty，系统不定时的将dirty的数据写回磁盘，以保持内存数据与硬盘数据的一致性。 可使用sync命令 来强制将内存中的dirty数据写回到磁盘中去。 文件系统的简单操作磁盘与目录的容量：df，du df：列出文件系统的整体磁盘使用量 -h：以人们较易阅读的GB/MB/KB等格式自行显示； -i：以inode的数量来显示。 du：评估文件系统的磁盘使用量 -h：以人们较易阅读的GB/MB/KB等格式自行显示； -s：列出总量而已。 连接文件：ln hard link（硬连接或实际连接） hard link只是在某个目录下新建一条文件名连接到某inode号码的关联记录而已； 如果你将任何一个文件名删除，其实inode与block还是存在的； 通常情况下，不占用inode与block，只是在目录的block中添加一条记录而已。 Hard link的限制为： 不能跨文件系统； 不能连接到目录。 symbolic link（符号连接，即快捷方式） symbolic link实际上是创建一个独立的文件指向某个文件的文件名，会占用inode与block。 ln [-sf] -s：默认硬连接，添加s为符号连接； -f：如果目标文件存在时，直接删除后再创建。 目录的连接数量新建目录连接数为2，且上一级目录增加1，因为创建目录时会出现3个东西： filename filename/. 当前目录 filename/.. 上一级目录 前两个等同，第三个为上一级目录。 磁盘的分区、格式化、检验与挂载磁盘分区：fdisk fdisk /dev/hdc 1234567891011121314151617181920212223Welcome to fdisk (util-linux 2.23.2).Changes will remain in memory only, until you decide to write them.Be careful before using the write command.Command (m for help): mCommand action a toggle a bootable flag b edit bsd disklabel c toggle the dos compatibility flag d delete a partition # 删除1个分区 g create a new empty GPT partition table G create an IRIX (SGI) partition table l list known partition types m print this menu n add a new partition # 新增一个分区 o create a new empty DOS partition table p print the partition table # 打印分区表 q quit without saving changes # 不存储退出 s create a new empty Sun disklabel t change a partition&apos;s system id u change display/entry units v verify the partition table w write table to disk and exit # 保存退出 x extra functionality (experts only) 输入p打印分区表： 12345678910111213Command (m for help): pDisk /dev/sda: 42.9 GB, 42949672960 bytes, 83886080 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0x000d5bbd Device Boot Start End Blocks Id System/dev/sda1 * 2048 411647 204800 83 Linux/dev/sda2 411648 61847551 30717952 83 Linux/dev/sda3 61847552 83886079 11019264 83 Linux# 设备文件名 开机区否 开始柱面 结束柱面 1KB大小容量 磁盘分区内的系统 fdisk –l 查询所有分区情况 1234567891011Disk /dev/sda: 42.9 GB, 42949672960 bytes, 83886080 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytes # 扇区大小I/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0x000d5bbd Device Boot Start End Blocks Id System/dev/sda1 * 2048 411647 204800 83 Linux/dev/sda2 411648 61847551 30717952 83 Linux/dev/sda3 61847552 83886079 11019264 83 Linux 注意，只要最后不按w，之前的所有操作均无效，所以可以练习删除及新增分区。 新增分区需要注意的地方： SATA硬盘最多支持到15号的分区，IDE最多支持到63号； fdisk没有办法处理大于2TB以上的磁盘分区（2TB以上使用GNU的parted命令）。 磁盘格式化 mkfs（make file system） [-t 文件系统格式] 设备文件名 -t：可以接文件系统格式，例如ext3，ext2，vfat等（系统有支持才会生效）。 mkefs 1234mke2fs [ -c | -l filename ] [ -b block-size ] [ -D ] [ -f fragment-size ] [ -g blocks-per-group ] [ -G number-of-groups ] [ -i bytes-per-inode ] [ -I inode-size ] [ -j ] [ -J journal-options ] [ -N number-of-inodes ] [ -n ] [ -m reserved-blocks-percentage ] [ -o creator-os ] [ -O feature[,...] ] [ -q ] [ -r fs-revision-level ] [ -E extended-options ] [ -v ] [ -F ] [ -L volume-label ] [ -M last-mounted-directory ] [ -S ] [ -t fs-type ] [ -T usage-type ] [ -U UUID ] [ -V ] device [ blocks-count ] 磁盘检验：fsck，badblocksfsck：File System Check 磁盘挂载：mount磁盘参数修改：mknod设备的文件有magor与minor数值： ll /dev/sda* 12345brw-rw----. 1 root disk 8, 0 Nov 6 02:07 /dev/sdabrw-rw----. 1 root disk 8, 1 Nov 6 02:07 /dev/sda1brw-rw----. 1 root disk 8, 2 Nov 6 02:07 /dev/sda2brw-rw----. 1 root disk 8, 3 Nov 6 02:07 /dev/sda3# 8：magor（主设备代码） 0-3：minor（次设备代码） 设置开机挂载开机挂载 cat /etc/fstab 1234UUID=c08f8c76-c1ea-48fd-8423-a33d6145a329 / ext4 defaults 1 1UUID=9b54bd04-5920-4bf5-b94b-1ab6a753c373 /boot ext4 defaults 1 2UUID=5c47e29d-176f-464d-ba1f-e5fa98e9a02f /home ext4 defaults 1 2UUID=fbc385ee-49c6-45b0-bc2b-248a599f6f21 swap swap defaults 0 0 UUID码全称是通用唯一识别码 (Universally Unique Identifier, UUID),它 是一个软件建构的标准，亦为自由软件基金会 (Open Software Foundation, OSF) 的组织在分布式计算环境 (Distributed Computing Environment, DCE) 领域的一部分。UUID 的目的，是让分布式系统中的所有元素，都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。 第二列：挂载点； 第三列：磁盘分区的文件系统； 第四列：文件系统参数； 第五列：能否被dump备份命令作用。 0：不要做dump备份；1：每天进行dump备份；2：其他不定日期dump备份 第六列：是否以fsck检验扇区。 开机的过程中，系统默认会以fsck检验我们的文件系统是否完整； 特殊文件系统不需要检验，如swap、/proc与/sys等； 0：不检验 1：优先检验 2：次要检验 注意：/etc/fstab为开机时的配置文件，实际文件系统的挂载是记录到etc/mtab与/proc/mounts这两个文件中去的。 特殊设备loop挂载 内存交换空间（swap）的构建使用物理分区构建swap的功能就是在应付物理内存不足的情况下所造成的内存扩展记录的功能。 新建swap分区的方法： 分区：先使用fdisk在你的磁盘中分出一个分区给系统作为swap； 操作完之后，执行partprobe让内核更新分区表。 格式化：mkswap 设备文件名； 使用：swap设备启动，swapon 设备文件名； 查看：通过free命令查看内存的使用情况。 swap使用上的限制 单一swap已经没有2GB的限制； 最多仅能创建32个swap； swap总量最大仅能达64GB。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux教程3--文件与目录管理]]></title>
    <url>%2FLinux%E6%95%99%E7%A8%8B3--%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[本文为Linux系列教程的第1篇，主要讲解主机规划和磁盘分区，参考书籍为鸟哥的Linux私房菜。 目录的相关操作比较特殊的目录 .：代表当前的目录，也可以用./来表示； ..：代表上一层目录，也可以用../来表示； ~:代表当前用户的主目录； -：代表前一个工作目录； ~account：代表account这个用户的主目录。 常见的处理目录的命令 cd（change directory）：切换目录； pwd（print working directory）：显示当前目录； mkdir（make directory）：新建一个新的目录； 默认情况下，所需要的目录得一层一层创建才可以，如果想直接创建，可以添加-p参数。 rmdir（remove directory）：删除一个空的目录。 默认情况下，所需要的目录得一层一层删除才可以，如果想直接删除，可以添加-r参数。 文件与目录管理查看文件和目录 ls: -a：全部的文件； -d：仅列出文件本身； -l：列出长数据串。 注意：ll为ls –l的简写。 复制、删除与移动 cp（copy，复制文件或目录） -a：相当于-pdr的意思； -i：若目标文件（destination）已经存在时，在覆盖时会先询问操作的进行； -r：目录递归持续复制。 rm（remove，删除文件或目录） -f：force的意思，忽略不存在的文件； -i：互动模式，删除前会询问用户是否操作； -r：目录递归持续删除。 mv（move，移动文件或目录） -f：force的意思，如果目标文件已存在，强制覆盖； -i：互动模式； -u：若目标文件已经存在，且source比较新，才会更新（update）。 文件内容查阅文件内容查看 cat（concatenate）：由第一行开始显示文件内容； -n：打印出行号 tac（反向列示）； nl（添加行号打印）； -b：指定行号指定的方式： -b a：表示不论是否为空行，也同样列出行号（类似于cat -n）； -b t：如果有空行，空行不列出行号（默认值）。 -n：列出行号表示的方法: -n ln：行号在最左方显示； -n rn：行号在最右方显示，且不加零； -n rz：行号在最右方显示，且加零。 -w：行号字段占用的位数。 可翻页查看（more和less）； 数据选取（head/tail [-n number] 文件）； od（非纯文本文件） 文件时间属性 modification time（mtime） 内容被修改时，更新； status time（ctime） 权限和属性被修改时，更新； access time（atime） 被取用时，更新。 touch命令 创建一个空的文件； 将某个文件的日期修改为当前日期（mtime和atime）。 文件默认权限（umask）Umask就是指定当前用户在新建文件或目录时候的权限默认值，获取方式如下： 12umask return 0022umask –S return u=rwx, g=rx, o=rx 数字代表缺失的权限。 root的umask默认为022，这是基于安全的考虑，至于一般身份用户，通常他们的umask为002，即保留同用户组的写入权利。 查看文件类型：file 命令与文件的查询脚本文件名的查询 which: -a：将所有由PATH目录中可以找到的命令均列出，而不只是第一个被找到的命令名称。 文件名的查找 find低效（查找硬盘），通常采用whereis或者locate，这两个均采用数据库来查找，所以较为快速。 whereis -b：只找二进制文件； -m：只找说明文件manual下的文件； -s：只找source源文件； -u：查找不在上述三个选项当中的其他特殊文件。 locate -i：忽略大小写的差异； -r：后面可接正则表达式的显示方式。 locate是根据已创建的数据库/var/lib/mlocate/里面的数据所查找到的，该库默认一天更新一次，所以会有延时； 强制更新数据库的命令为updatedb，该命令根据/etc/updated.conf的设置去寻找系统硬盘内的文件名，并更新var/lib/mlocate/内的数据库文件。 find 与时间有关的参数（mtime/ctime/atime） 1234-mtime n：n天之前的一天之内被更改过的文件；-mtime +n：n天之前（不含n天本身）被更改过的文件；-mtime -n：n天之内（含n天本身）被更改过的文件；-newer file：列出比file更新的文件名。 与用户或用户组名有关的参数 123456-uid：用户ID；-gid：用户组ID；-user name：name为用户名称；-group name：name为用户组名称；-nouser-nogroup 与文件权限及名称相关的参数 1234567-name filename：查找文件名为filename的文件；-size [+-] SIZE：查找比SIZE还要大（+）或小（-）的文件，SIZE的规格有：c：Bytes，k：1024 Bytes；-type TYPE：TYPE的类型有：一般正规文件（f）、设备文件（b/c）、目录（d）、连接文件（l）、socket（s）、FIFO（p）等属性；-perm mode：文件权限刚好等于mode的文件；-perm -mode：文件权限大于等于mode的文件；-perm +mode：文件权限小于等于mode（子集）的文件； 其他可进行的操作 12-exec command：command为其他命令；-print：将结果打印到屏幕上，默认操作。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hadoop系列教程1--概述]]></title>
    <url>%2FHadoop%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B1--%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[本文为Hadoop系列教程的第1篇，主要介绍Hadoop的产生背景及其架构等。 Hadoop产生背景 Hadoop最早起源于Nutch，Nutch的目标是设计构建一个大型的全网搜索引擎，包括网页抓取、索引、查询等功能，但随着抓取网页数量的增加，遇到了严重的可扩展性问题——如何解决数十亿网页的存储和索引问题。 2003年、2004年、2005年年谷歌发表的两篇论文为该问题提供了可行性方案： 03分布式文件系统（GFS），可用于处理海量网页的存储； 04分布式计算框架MapReduce，可用于处理海量网页的索引计算； 05BigTable—被Hadoop借鉴，即Hbase（非关系型数据库）。 Nutch的开发人员完成了相应的开源实现HDFS和MapReduce，并从Nutch中剥离出来成为独立项目Hadoop，到2008年1月，Hadoop成为Apache顶级项目，迎来了它的快速发展期。 什么是Hadoop？ Hadoop是Apache（archive.apache.org/dist/）旗下的一套开源软件； Hadoop提供的功能：利用服务器集群对数据进行存储，根据用户的自定义业务逻辑，对海量数据进行分布式计算； 广义上来讲，Hadoop通常是指一个更广泛的概念—Hadoop生态圈。 下图为Hadoop生态圈示意图： 重点组件： 名字来源：作者女儿的玩具名为Hadoop HDFS：分布式文件系统； MapReduce：分布式运算程序开发框架； Sqoop：关系型数据库与HDFS数据相互迁移工具； Flume：日志数据采集框架； Zookeeper：分布式协调服务基础组件； Hive：SQL数据仓库工具，支持SQL语言的框架（将SQL语句翻译成底层的MapReduce指令）； Pig：高级的API，支持SQL语言的框架（将SQL语句翻译成底层的MapReduce指令）； Mahout：机器学习框架； YARN：资源调度系统； Hbase：基于Hadoop分布式海量数据库。 Hadoop解决了什么问题？ 海量数据的存储（HDFS）； 海量数据的技术（MapReduce）； 资源调度（YARN）。 分布式架构问题单机的问题 存储的能力有限； 计算能力有限； 有单点故障； …… 分布式架构解决了单机的问题经典分布式主从架构（Master-Slave） Master负责管理（相当于老大），Master可以有多个，防止单点故障的发生，多个老大选举（Zookeeper框架负责）； Slave负责干活（相当于小弟），Salve有多个，并且可以动态的添加或移除； 优先使用Linux系统（主要开源免费，节省成本）。 Hadoop架构 Hadoop2.0： HDFS： Master：NameNode（老大）； Salve：DataNode（小弟）。 YARN： Master：ResourceManager（老大）； Slave：NodeManager（小组长）。]]></content>
      <categories>
        <category>Hadoop</category>
      </categories>
      <tags>
        <tag>大数据</tag>
        <tag>Hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux教程2--文件权限与目录设置]]></title>
    <url>%2FLinux%E6%95%99%E7%A8%8B2--%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[本文为Linux系列教程的第1篇，主要讲解主机规划和磁盘分区，参考书籍为鸟哥的Linux私房菜。 Linux文件权限通过命令’ls -al’可以查看当前目录下的文件权限，如下图所示： 第一列代表这个文件的类型和权限： 第一个字符代表这个文件是“目录、文件或者链接文件等” [d]：目录 [-]：文件 [l]：连接文件（linkfile） [b]：设备中可供存储的接口设备 [c]：设备中的串行接口设备，例如键盘、鼠标等 接下来的字符，以3个为1组，且均为rwx3个参数的组合，[r]代表可读（read），[w]代表可写（write），[x]代表可执行（execute）。要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现[-]而已。依次为用户权限、同用户组权限、其他用户权限。 第二列代表有多少个文件名连接到此节点（i-node） 第三列代表这个文件（或目录）的所有者账号 第四列代表这个文件（或目录）的所属用户组 第五列为文件大小，默认单位为B 第六列为创建日期或最近修改日期 第七列为文件名 改变文件属性和权限 chgrp：改变文件所属用户组； 要被改变的用户组名必须在/etc/group文件内存在才可以。 chown：改变文件所属用户； 要被改变的用户名必须在/etc/group文件内存在才可以。 chmod：改变文件的权限。 可以使用数字来代表权限： [r]：4 [w]：2 [ x ]：1 3个权限的分数需要累加； 1chmod 777 filename 符号类型改变文件权限： 命令头部 用户 操作 权限 chmod u（user） g（group） o（others） a（all） +（加入） -（除去） =（设置） r w x 目录与文件的权限含义权限对文件的重要性 [r]：可读取此文件的实际内容； [w]：可以编辑、新增、修改该文件的内容（但不包括删除该文件）； [ x ]：此文件具有可被系统执行的权限。 权限对目录的重要性 [r]：具有读取目录结构列表的权限； [w]： 具有更改该目录结构列表的权限； 新建新的文件和目录； 删除已经存在的文件和目录（不论该文件的权限为何）； 将已存在的文件和目录进行重命名； 转移该目录内的文件、目录位置。 ：用户能否进入该目录成为工作目录（working directory）。 需要注意的是，要开放目录给任何人浏览时，应该至少给予 [r]和[x] 的权限，仅仅给[r]的权限，则只能获取该目录下的文件列表，获取不到具体的文件。 Linux文件种类和扩展名文件种类 第一个属性为[-]，主要包括普通文件（regular file）、纯文本文件（ASCII）、二进制文件（binary）、数据格式文件（data）。 第一个属性为[d]，代表目录（directory）。 第一个属性为[l]，代表连接文件（link file）。 设备与设备文件（device）,与设备外设和存储等相关的一些文件，通常均集中在/dev目录下，通常可分为两种: 块（block）设备文件，就是一些存储数据，以提供系统随机访问的接口设备，例如硬盘、软盘等，第一个属性为[b]； 字符（character）设备文件，即是一些串行端口的接口设备，例如键盘、鼠标等。这些设备的特征是“一次性截取”，不能够截断输出，第一个属性为[c]。 套接字（sockets）：通常被用于网络上的数据连接，其第一个属性为[s]。 管道（FIFO，pipe）类似于Windows下的快捷方式，主要目的在解决多个程序同时访问一个文件所造成的错误问题。FIFO是first-in-first-out的缩写，第一个属性为[p]。 Linux文件扩展名一个Linux文件能不能被执行，与它的第一列的10个属性有关，与文件名没有关系，只要你的权限中有[x]的话，代表这个文件可被执行。可执行不代表能够执行成功，能否执行成功取决于文件的内容。常见的文件扩展名： *.sh：脚本或批处理文件； .Z、.tar、.tar.gz、.zip、*.tgz：经过打包的压缩文件； .html、.php：网页相关文件。 Linux文件名长度限制采用Ext2/Ext3文件系统时，针对文件的文件名长度限制为： 单一文件和目录的最大容许文件名为255个字符； 包含完整路径名称及目录（/）的完整文件名为4096个字符。 Linux目录配置Linux目录配置标准（FHS）FHS（Filesystem Hierarchy Standard）： 可分享的（shareable） 不可分享的（unshareable） 不变的（static） /usr（软件放置处） /opt（第三方软件） /etc（配置文件） /boot（开机与内核文件） 可变动的（variable） /var/mail（用户邮件信箱） /var/spool/news（新闻组） /var/run（程序相关） /var/lock（程序相关） /（root）：根目录，与开机系统有关；/usr（UNIX software resource）：与软件安装/执行相关；/var（variable）：与系统运作过程有关。 不可与根目录分开的目录： /etc：配置文件； /bin：重要执行文件； /dev：所需要的设备文件； /lib：执行文件所需的函数库与内核所需的模块； /sbin：重要的系统执行文件。 目录树（directory tree） 目录树的起始点为根目录（root，/）； 每一个目录不仅可以使用本地端的文件系统，也可以使用网络上的文件系统。举例来说，可以利用Network File System（NFS）服务器挂载特定目录； 每一个文件在此目录树中的文件名（包含完整路径）都是独一无二的。 绝对路径与相对路径 绝对路径：由根目录（/）开始写起的文件名或目录名称； 相对路径：相对于当前路径的文件名写法。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux教程1--主机规划和磁盘分区]]></title>
    <url>%2FLinux%E6%95%99%E7%A8%8B1--%E4%B8%BB%E6%9C%BA%E8%A7%84%E5%88%92%E5%92%8C%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA%2F</url>
    <content type="text"><![CDATA[本文为Linux系列教程的第1篇，主要讲解主机规划和磁盘分区，参考书籍为鸟哥的Linux私房菜。 各硬件设备在Linux中的文件名在Linux系统中，每个设备均被当做一个文件对待，几乎所有的硬件设备文件均在/dev这个目录内； IDE接口的硬盘文件名为/dev/hd[a-d]； SATA接口的硬盘文件名为/dev/sd[a-p]。 磁盘分区磁盘连接的方式与设备文件名间的关系 IDE接口：通常主机会有2个IDE接口，每个接口可以接2个设备，两接口通常被称为IDE1（primary）和IDE2（secondary），每个接口上的设备被区分为master设备和slave设备。 IDE master slave IDE1（primary） /dev/hda /dev/hdb IDE2（secondary） /dev/hdc /dev/hdd SATA接口：根据Linux内核检测到磁盘的顺序，跟接口编号没关系。 磁盘的组成复习磁盘扇区每个为512Bytes，整块硬盘的第一个扇区特别重要，主要记录了2个重要信息： 主引导分区（Master Boot Record, MBR），可以安装引导加载程序的地方，有446 Bytes； 分区表（partition table）：记录整块硬盘分区的状态，有64 Bytes。 磁盘分区表由于分区表只有64 Bytes，最多容纳四个分区，这四个分区为主（Primary）或扩展（Extended）分区，分区的最小单位为柱面（cylinder）；扩展分区继续切分出来的分区成为逻辑分区（logical partition）；主分区和扩展分区最多只有4个（硬盘的限制）；扩展分区最多只有一个（操作系统的限制）；能被格式化作为数据访问的分区是主分区和逻辑分区，扩展分区无法被格式化。 安装模式下，磁盘分区的选择 目录树结构 整个目录树结构最重要的是根目录（root directory），表示方法为/；所有的文件均是由根目录衍生来的；文件数据实际上存储在磁盘分区中，利用挂载的方式来结合目录树的架构与磁盘内的数据。 文件系统与目录树之间的关系（挂载） 所谓挂载就是利用一个目录作为进入点，将磁盘分区的数据放置在该目录下，也就是说，进入该目录就可以读取该分区。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基础语法]]></title>
    <url>%2FMarkdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Markdown是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档。由于不同平台、网站Markdown引擎不完全相同，本文主要展示Hexo下的Markdown语法。 段落标题 #1级标题 ##2级标题 …级标题 注意：几个#号则代表几级标题，最多6级。 段落缩进1234半方大的空白&amp;ensp;或&amp;#8194;看，飞碟全方大的空白&amp;emsp;或&amp;#8195;看，飞碟不断行的空白格&amp;nbsp;或&amp;#160;看，飞碟&amp;emsp;&amp;emsp;段落从此开始。 半方大的空白&ensp;或&#8194;看，飞碟全方大的空白&emsp;或&#8195;看，飞碟不断行的空白格&nbsp;或&#160;看，飞碟&emsp;&emsp;段落从此开始。 文字字体、字号、颜色123456&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;&lt;font color=#0099ff size=12 face=&quot;黑体&quot;&gt;黑体&lt;/font&gt;&lt;font color=#00ffff size=3&gt;null&lt;/font&gt;&lt;font color=gray size=5&gt;gray&lt;/font&gt; 我是黑体字我是微软雅黑我是华文彩云黑体nullgray 粗体、斜体、删除线12345**粗体**__粗体__*斜体*_斜体_~~删除线~~ 粗体粗体斜体_斜体_删除线 代码块在三斜点之间添加代码即可。 需要注意的是：上述的斜点并不是单引号，这个是初学者常犯的错误，它是键盘Tab键和Esc键之间的东东（就是带~标志的键）！ 指定代码形式，在后面追加形式说明即可，如： 显示为： 12345import mathdef add_all(n): total = n * (n + 1) / 2 return total 列表无序列表一个星号 / 一个加号 / 一个减号 +若干个空格 + 列表项内容 123* 章节1- 章节2+ 章节3 章节1 章节2 章节3 有序列表一个数字 + 一个英文句点 + 若干个空格 + 列表项内容 1231. 章节12. 章节23. 章节3 章节1 章节2 章节3 嵌套列表123456- 嵌套列表1 + 嵌套列表2 + 嵌套列表3 - 嵌套列表4 * 嵌套列表5- 嵌套列表6 嵌套列表1 嵌套列表2 嵌套列表3 嵌套列表4 嵌套列表5 嵌套列表6 表格实例代码12345| 项目 | 价格 | 数量 || -------- | -----: | :----: || 计算机 | \$1600 | 5 || 手机 | \$12 | 12 || 管线 | \$1 | 234 | 第2行通过左右的’:’设置表格的对齐形式，元素左边1个冒号为左对齐，右边1个为右对齐，两边均有为居中。 展现形式 项目 价格 数量 计算机 \$1600 5 手机 \$12 12 管线 \$1 234 链接索引链接1[阮树斌的个人博客](http://ruanshubin.top) 阮树斌的个人博客 自动链接（尖括号）1&lt;http://ruanshubin.top&gt; http://ruanshubin.top 图片链接1![GitHub Mark](http://github.global.ssl.fastly.net/images/modules/logos_page/GitHub-Mark.png &quot;GitHub Mark&quot;) 设置图片大小的话只能借助HTML标记。 下面为流程图、序列图、甘特图的Mrakdown语法，需要注意的是Github上还未支持上述三种图的实现，我用Cmd Markdown编辑阅读器来实现相关语法并截图展示。 绘制流程图定义元素的语法1tag=&gt;type:content:&gt;url tag为元素名字 type是元素的类型，共六种 start # 开始 end # 结束 operation # 操作 subroutine # 子程序 input # 输入 ouput #输出 content为流程框中显示的内容，需要注意的是:与文本之间有空格 url为链接，与流程框中的内容绑定 流程图简单示范123456789flowst=&gt;start: 开始op=&gt;operation: 操作cond=&gt;condition: 是或否？e=&gt;end: 结束st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 生成流程图如下： 可以发现，生成流程图主要分为2步： 定义元素 定义连接关系 高效绘制序列图1234```seqAlice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 高效绘制甘特图1234567891011121314```gantt title 项目开发流程 section 项目确定 需求分析 :a1, 2016-06-22, 3d 可行性报告 :after a1, 5d 概念验证 : 5d section 项目实施 概要设计 :2016-07-05 , 5d 详细设计 :2016-07-08, 10d 编码 :2016-07-15, 10d 测试 :2016-07-22, 5d section 发布验收 发布: 2d 验收: 3d 公式开启公式支持Hexo 的自带的 Markdown 引擎并不支持 LaTeX 公式。 但是 MathJax 支持，因此首先要启用 MathJax 才能输入 LaTeX 公式。如果你已经安装了 NexT theme，开启 MathJax 非常容易，在 NexT 主题的 _config.yml 文件里，找到 MathJax 相关部分，使用以下配置： 12345# MathJax Supportmathjax: enable: true per_page: false cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML 实例12345\begin&#123;align&#125;x &amp;= a + b + c + d\\\\ &amp;= e + f\\\\ &amp;= g\end&#123;align&#125; \begin{align}x &amp;= a + b + c + d\\ &amp;= e + f\\ &amp;= g\end{align} 需要注意的是， LaTeX 公式编辑代码中与Hexo中特殊字符重合时，需要添加\符号进行转义 123456789\begin&#123;aligned&#125;f_Y(y) &amp; = f_X[h(y)]|h&apos;(y)| \\\\&amp; = f_X[h(y)]h&apos;(y) \\\\&amp; = \frac&#123;1&#125;&#123;\theta&#125;e^&#123;-\frac&#123;x&#125;&#123;\theta&#125;&#125;[\frac&#123;dx&#125;&#123;dy&#125;(-\frac&#123;\theta&#125;&#123;ln(1-y)&#125;)] \\\\&amp; = \frac&#123;1&#125;&#123;\theta&#125;e^&#123;-\frac&#123;-\frac&#123;\theta&#125;&#123;ln(1-y)&#125;&#125;&#123;\theta&#125;&#125;\frac&#123;\theta&#125;&#123;1-y&#125; \\\\&amp; = \frac&#123;1&#125;&#123;\theta&#125;e^&#123;ln(1-y)&#125;\frac&#123;\theta&#125;&#123;1-y&#125; \\\\&amp; = \frac&#123;1-y&#125;&#123;\theta&#125;\frac&#123;\theta&#125;&#123;1-y&#125; \\\\&amp; = 1 \\\\\end&#123;aligned&#125; \begin{aligned}f_Y(y) &amp; = f_X[h(y)]|h’(y)| \\&amp; = f_X[h(y)]h’(y) \\&amp; = \frac{1}{\theta}e^{-\frac{x}{\theta}}[\frac{dx}{dy}(-\frac{\theta}{ln(1-y)})] \\&amp; = \frac{1}{\theta}e^{-\frac{-\frac{\theta}{ln(1-y)}}{\theta}}\frac{\theta}{1-y} \\&amp; = \frac{1}{\theta}e^{ln(1-y)}\frac{\theta}{1-y} \\&amp; = \frac{1-y}{\theta}\frac{\theta}{1-y} \\&amp; = 1 \\\end{aligned}]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scala实战--数值]]></title>
    <url>%2FScala%E5%AE%9E%E6%88%98--%E6%95%B0%E5%80%BC%2F</url>
    <content type="text"><![CDATA[Scala所有的数值都是对象，包括Bytes、char、Double、Float、 Int、Long和Short。 从字符串到数值使用String的to*方法： 123&quot;100&quot;.toInt&quot;100&quot;.toDouble&quot;100&quot;.toByte BigInt和BigDecimal也可以通过字符串创建： 12val a = BigInt(&quot;1&quot;)val b = BigDecimal(&quot;3.1415926&quot;) 处理基数和根，Scala中的toInt方法不支持传入进制，为解决这个问题，可以使用 java.lang.Integer类的parseInt方法： 123Integer.parseInt(&quot;100&quot;,2)Integer.parseInt(&quot;100&quot;,8)Integer.parseInt(&quot;100&quot;,16) 也可以通过隐式转换类的方法来解决这个问题： 12345implicit class StringToInt(s: String)&#123; def toInt(radix: Int) = Integer.parseInt(s, radix)&#125;&quot;100&quot;.toInt(2) 处理NumberFormatException时，通常使用Option/Some/None模式来处理这类问题： 1234567def toInt(s: String): Option[Int] = &#123; try&#123; Some(s.toInt) &#125;catch&#123; case e: NumberFormatException =&gt; None &#125;&#125; 通过getOrElse方法调用： 12println(toInt(&quot;1&quot;).getOrElse(0)) // 1println(toInt(&quot;a&quot;).getOrElse(0)) // 0 或者通过模式匹配调用： 12345678910toInt(&quot;a&quot;) match&#123; case Some(n) =&gt; println(n) case None =&gt; println(&quot;Boom！That wasn&apos;t a number！&quot;)&#125;// 返回值var result = toInt(&quot;a&quot;) match&#123; case Some(n) =&gt; n case None =&gt; 0) &#125; 数值类型转换to*方法 替代++和–Scala中无++、–操作符，可用+=和-=替代。 浮点数的比较123val a = 0.3 // 0.3val b = 0.1 + 0.2 // 0.30000000000000004a == b // False 解决方法：自定义约等于方法 12345678object MathUtils&#123; def ~=(x:Double, y:Double, precision:Double)&#123; if((x-y).abs &lt; peecision) true else false &#125;&#125;// 静态方法调用MathUtils.~=(a, b, 0.000001) 成随机数使用Scala的Scala.util.random： 1234val r = scala.util.randomr.nextIntr.nextInt(100)r.nextDouble 生成区间数123val a = 1 to 100 // [1, 100]val a = 1 until 100 // [1, 100)val a = 1 to 100 by 3 // 3为步长]]></content>
      <categories>
        <category>Scala</category>
      </categories>
      <tags>
        <tag>Scala</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scala实战--映射和元组]]></title>
    <url>%2FScala%E5%AE%9E%E6%88%98--%E6%98%A0%E5%B0%84%E5%92%8C%E5%85%83%E7%BB%84%2F</url>
    <content type="text"><![CDATA[构建映射1val scores = Map(&quot;Alice&quot; -&gt;10, &quot;Bob&quot; -&gt; 3, &quot;Clindy&quot; -&gt;8) 上述代码构建的Map，其值不能被改变，构建可变映射，则用： 1val scores = scala.collection.mutable.Map&quot;Alice&quot; -&gt;10, &quot;Bob&quot; -&gt; 3, &quot;Clindy&quot; -&gt;8) 也可用以下方式定义映射： 1var scores = Map((&quot;Alice&quot;, 10), (&quot;Bob&quot;, 3), (&quot;Cindy&quot;, 8)) 获取映射中的值123456789val bobsScore = scores(&quot;Bob&quot;)// 类似于Java中的scores.get(&quot;Bob&quot;)// 检查映射中是否包含某键值，可用contions方法scores.contions(&quot;Bob&quot;)// return Trueval bobsScore = scores.getOrElse(&quot;Bob&quot;, 0)// 如果映射包含键&quot;Bob&quot;，返回对应的值；否则，返回0 更新映射中的值123456789101112scores(&quot;Bob&quot;) = 10 // scores必须为可变映射scores(&quot;Fred&quot;) = 7 //增加新的键并赋值// 可用+=操作来添加多个关系(不可变映射也可以)scores += (&quot;Bob&quot; -&gt; 10, &quot;Fred&quot; -&gt; 7)// 移除某个键，可用-=score -= &quot;Alice&quot;// 虽然不能更新不可变映射，但可是新建不可变映射的方法实现更新（曲线救国）var newScores = scores + (&quot;Bob&quot; -&gt; 10, &quot;Fred&quot; -&gt; 7) // 更新过的新映射// newScores映射包含了与scores相同的映射关系，此外&quot;Bob&quot;被更新，&quot;Fred&quot;被添加进来 除了把结果作为新值保存外，也可以直接更新var变量： 12var scores = ...scores = scores + (&quot;Bob&quot; -&gt; 10, &quot;Fred&quot; -&gt; 7) 迭代映射12345for ((key, value) &lt;- Map)// 获取映射键集合scores.keySet// 获取映射值,return Iterablescores.values 元组映射是键/值对偶的集合。对偶是元组（tuple）的最简单形态——元组是不同类型的值的聚集。 12345val t = (1, 3.14, &quot;Fred&quot;)// 可以用_1,_2,_3访问其组元val second = t._2 // 将second设为3.14,其中t._2也可写为t _2（.替换为空格）val (first, second, third) = t // 将first设为1，second设为3.14，third设为&quot;Fred&quot;val (first, second, _) = t // 只返回部分]]></content>
      <categories>
        <category>Scala</category>
      </categories>
      <tags>
        <tag>Scala</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scala实战--字符串]]></title>
    <url>%2FScala%E5%AE%9E%E6%88%98--%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[测试字符串的相等性“==”方法12345val s1 = &quot;Hello&quot;val s2 = &quot;Hello&quot;val s3 = &quot;H&quot; + &quot;ello&quot;s1 == s2 // return：Trues2 == s3 // return：True 不考虑字符大小写不考虑字符大小写的话，可以将比较字符串先统一转换成大写或小写，再进行”==”操作： 123val s1 = &quot;hello&quot;val s2 = &quot;Hello&quot;s1.toUpperCase == s2.toUpperCase // return: True equalsIngoreCase方法也可以退而求其次，使用Java字符串类的equalsIngoreCase方法 123val s1 = &quot;hello&quot;val s2 = &quot;Hello&quot;s1.equalsIgnoreCase(s2) // return: True 创建多行字符串在Scala中可以用3个双引号创建多行字符串 123val foo = &quot;&quot;&quot;This is a multiline String&quot;&quot;&quot; 分隔字符串使用大名鼎鼎的split命令 1&quot;Hello,World&quot;.split(&quot;,&quot;) // return： Array(Hello, World) split方法接受正则表达式： 1&quot;hello world, this is Al&quot;.split(&quot;\\s+&quot;) // return: Array(hello, world, this, is, Al) 分隔并实现各要素头尾空格的去除： 1&quot;aaa, bbb,ccc, ddd &quot;.split(&quot;,&quot;).map(_.trim) // trim命令为去除字符串头尾空格 进一步可以通过replaceAll的方法实现字符串要素中所有空格的去除： 12&quot;aa b,ccc , d d d&quot;.split(&quot;,&quot;) // return: Array(aa b,ccc , d d d)&quot;aa b,ccc , d d d&quot;.split(&quot;,&quot;).map(_.replaceAll(&quot; &quot;,&quot;&quot;)) // return: Array(aab,ccc,ddd) 字符串中的变量代换本质上就是格式化字符串。 字符串前加字母”s”，字符串中的变量前添加”$”123val name = &quot;Tom&quot;val age = 18println(s&quot;$name is $age years old!&quot;) // return: Tom is 18 years old! 在字符串中使用变量表达式时，需要用{}包裹： 12val age = 18println(s&quot;Age next year:$&#123;age + 1&#125;&quot;) // return: Age next year:19 同时，访问对象的属性时，也要求用{}包裹： 123case class Student(name:String, score:Int)val Tom = Student(&quot;Tom&quot;, 99)println(s&quot;$&#123;Tom.name&#125; has a score of $&#123;Tom.score&#125;&quot;) 字符串前加字母”f”，字符串中的变量前添加”$”，变量后添加”%”设置格式：123val name = &quot;Fred&quot;val weight = 200.00println(f&quot;$name weghts $weght%.0f pounds!&quot;) format方法（类似于Python中的格式化字符串）1println(&quot;%s is %d years old&quot;.format(name, age)) printf的格式化常用符： %c：字符 %d：十进制数字 %e：指数浮点数 %f：浮点数 %i：整数（十进制） %o：八进制数 %s：字符串 %u：无符号十进制数 %x：十六进制数 %%：打印一个百分号 \%：打印一个百分号 去除转义，可在字符串前添加”raw” 1println(raw&quot;foo\nbar&quot;) 遍历字符串map方法12345val upper = &quot;hello, world&quot;.map(c =&gt; c.toUpper)val upper = &quot;hello, world&quot;.map(_.toUpper)// 与filter过滤器组合使用val upper = &quot;hello, world&quot;.filter(_ != &apos;l&apos;).map(_.toUpper)// 注意&apos;l&apos;为Char，而非String，故为单引号，双引号会报错 for…yield1val upper = for (c &lt;- &quot;hello, world&quot;)yield c.toUpper 在for循环添加yield实际上是将每次循环的结果放到临时存放区中，当循环结束的时候，在临时存放区中的所有元素以一个集合的形式返回，其作用与map方法等同。 foreach循环打印： 1&quot;hello, world&quot;。foreach(println) 字符串中的查找模式判断字符串是否符合某个正则表达式。 匹配数字： 12345val numPattern = &quot;[0-9]+&quot;.rval address = &quot;123 Main Street Suite 101&quot;val match1 = numPattern.findFirstIn(address) // 第一个匹配的数字，返回：Option[String] = Some(123)val matchs = numPattern.findAllIn(address) // 返回的迭代器val matchs = numPattern.findAllIn(address).toArray // 返回数组 上面实例是通过字符串后面添加”.r”的方式创建正则表达式的，另外一种方式是引入Regex类 12import scala.util.matching.Regexvar numPattern = new Regex(&quot;[0-9]+&quot;) 抽取String中模式匹配的部分1234// 定义期望的模式val pattern = &quot;([0-9]+) ([A-Za-z]+)&quot;.r// 从目标字符串中提取正则组val pattern(count, fruit) = &quot;100 Bananas&quot; 访问字符串中的字符中的一个字符Java的charAt方法1&quot;hello&quot;.charAt(0) Scala的数组方法1&quot;hello&quot;(0)]]></content>
      <categories>
        <category>Scala</category>
      </categories>
      <tags>
        <tag>Scala</tag>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Scala实战--连接oracle及mysql数据库]]></title>
    <url>%2FScala%E5%AE%9E%E6%88%98--%E8%BF%9E%E6%8E%A5oracle%E5%8F%8Amysql%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[连接oracle数据库 Scala连接oracle数据库是通过Java的JDBC的方式实现的，具体实现方式如下： 在工程目录中添加oracle_jdbc的jar包‘build_path’-‘configure build path…’-‘libraries’-‘add exteral JARs’，添加oracle安装目录中的ojdbc6.jar包。 相关代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.sql.Connectionimport java.sql.DriverManagerimport scala.collection.mutable.ArrayBufferobject get_oracle&#123; def main(args:Array[String])&#123; val url = &quot;jdbc:oracle:thin:@xx.x.xx.xxx:port/database&quot; // 驱动名称 val = driver = &quot;oracle.jdbc.driver.OracleDriver&quot; // 用户名 val username = &quot;********&quot; // 密码 val password = &quot;********&quot; // 初始化数据连接 val connection:Connection = null // 初始化查询结果 val result = ArrayBuffer[String]() try&#123; // 注册Driver Class.forName(driver) println(&quot;开始尝试连接数据库&quot;) // 连接数据库 connection = DriverManager.getConnection(url, username, password) println(&quot;数据库连接成功&quot;) // 初始化查询语句 val statement = connection.createStatement // 执行查询结果，并返回结果 val rs = statement.executeQuery(&quot;select t.* from test&quot;) // 打印返回结果 var i = 1 while(rs.next)&#123; val item = rs.getString(&quot;name&quot;) result.append(item) i = i + 1 &#125; println(&quot;查询数据条数：&quot; + result.length) println(&quot;具体数据如下：&quot;)&#123; println(f&quot;第$&#123;i + 1&#125;条数据为：$&#123;result(i)&#125;&quot;) &#125; &#125; finally&#123; // connection.close println(&quot;数据查询成功&quot;) &#125; &#125;&#125; 连接mysql数据库 连接MySQL数据库与oracle数据库类似，区别在于链接和驱动不一样，加载相应的mysql驱动的jar包即可。 与oracle的区别1234// 不同于Oracle的部分val url = &quot;jdbc:mysql://localhost:3306/sys?useSSL=True&quot; // useSSL=True主要是因为mysql在高版本中需要指明是否进行SSL连接var driver = com.mysql.jdbc.Driver mysql驱动下载 mysql驱动下载地址为:https://dev.mysql.com/downloads/connector/j/]]></content>
      <categories>
        <category>Scala</category>
      </categories>
      <tags>
        <tag>Scala</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
</search>
