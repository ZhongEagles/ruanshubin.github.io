<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>阮树斌 | 技术改变生活</title>
  
  <subtitle>交通 | 数据 | 算法 &lt;br&gt; Python | Java | Scala | Matlab | GIS</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-05-04T04:10:19.716Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Ruan Shubin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据结构及算法--栈</title>
    <link href="http://yoursite.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95--%E6%A0%88/"/>
    <id>http://yoursite.com/数据结构及算法--栈/</id>
    <published>2018-04-09T01:00:00.000Z</published>
    <updated>2018-05-04T04:10:19.716Z</updated>
    
    <content type="html"><![CDATA[<h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><h3 id="三个基本属性"><a href="#三个基本属性" class="headerlink" title="三个基本属性"></a>三个基本属性</h3><ul><li><p>栈的存储数据data</p></li><li><p>栈的最大存储量maxSize</p></li><li><p>栈顶top</p></li></ul><h3 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"># Python 2.7</span><br><span class="line"></span><br><span class="line">class sqStack(object):</span><br><span class="line"></span><br><span class="line">    # 初始化</span><br><span class="line">    def __init__(self, maxSize):</span><br><span class="line">        self.data = [None] * maxSize</span><br><span class="line">        self.maxSize = maxSize</span><br><span class="line">        self.top = -1</span><br><span class="line">        </span><br><span class="line">    # 获取顺序栈长度  </span><br><span class="line">    def get_length(self):</span><br><span class="line">        return self.top + 1</span><br><span class="line">        </span><br><span class="line">    # 清空顺序栈   </span><br><span class="line">    def clear(self):</span><br><span class="line">        for i in range(self.get_length()):</span><br><span class="line">            self.data[i] = None</span><br><span class="line">        self.top = -1</span><br><span class="line">    </span><br><span class="line">    # 是否为空</span><br><span class="line">    def is_empty(self):</span><br><span class="line">        return self.top == -1</span><br><span class="line">            </span><br><span class="line">    # 是否满</span><br><span class="line">    def is_full(self):</span><br><span class="line">        return self.get_length() == self.maxSize</span><br><span class="line">            </span><br><span class="line">    # 进栈</span><br><span class="line">    def push(self, elem):</span><br><span class="line">        if self.is_full():</span><br><span class="line">            print &apos;Stack is full!&apos;</span><br><span class="line">        else:</span><br><span class="line">            self.top += 1</span><br><span class="line">            self.data[self.top] = elem</span><br><span class="line">            </span><br><span class="line">    # 出栈</span><br><span class="line">    def pop(self):</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            print &apos;Stack is empty!&apos;</span><br><span class="line">        else:</span><br><span class="line">            self.top -= 1</span><br><span class="line">            return self.data[self.top + 1]</span><br><span class="line">            </span><br><span class="line">    # 取栈顶元素</span><br><span class="line">    def get_top(self):</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            print &apos;Stack is empty!&apos;</span><br><span class="line">        else:</span><br><span class="line">            return self.data[self.top]</span><br><span class="line">            </span><br><span class="line">    # 由栈顶打印栈元素</span><br><span class="line">    def show_stack(self):</span><br><span class="line">        for i in range(self.get_length()-1, -1, -1):</span><br><span class="line">            print self.data[i]</span><br></pre></td></tr></table></figure><hr><h2 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h2><h3 id="节点的基本属性"><a href="#节点的基本属性" class="headerlink" title="节点的基本属性"></a>节点的基本属性</h3><ul><li><p>数据域data</p></li><li><p>后继指针next</p></li></ul><h3 id="链式栈的基本属性"><a href="#链式栈的基本属性" class="headerlink" title="链式栈的基本属性"></a>链式栈的基本属性</h3><ul><li><p>栈顶</p></li><li><p>链式栈的长度</p></li></ul><h3 id="Python实现-1"><a href="#Python实现-1" class="headerlink" title="Python实现"></a>Python实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"># Python 2.7</span><br><span class="line"></span><br><span class="line"># 节点</span><br><span class="line">class Node(object):</span><br><span class="line">    def __init__(self, data, next=None):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.next = next</span><br><span class="line">        </span><br><span class="line"># 链表</span><br><span class="line">class lkStack(object):</span><br><span class="line">    </span><br><span class="line">    # 初始化</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.top = Node(None)</span><br><span class="line">        self.length = 0</span><br><span class="line">        </span><br><span class="line">    # 是否为空</span><br><span class="line">    def is_empty(self):</span><br><span class="line">        return self.length == 0</span><br><span class="line">    </span><br><span class="line">    # 获取链表长度</span><br><span class="line">    def get_length(self):</span><br><span class="line">        return self.length</span><br><span class="line">        </span><br><span class="line">    # 进栈</span><br><span class="line">    def push(self, elem):</span><br><span class="line">        node = Node(elem, self.top)</span><br><span class="line">        self.top = node</span><br><span class="line">        self.length += 1</span><br><span class="line">        </span><br><span class="line">    # 出栈</span><br><span class="line">    def pop(self):</span><br><span class="line">        if self.length == 0:</span><br><span class="line">            print &apos;lkStack is empty!&apos;</span><br><span class="line">        else:</span><br><span class="line">            top = self.top</span><br><span class="line">            self.top = self.top.next</span><br><span class="line">            self.length -= 1</span><br><span class="line">            return top.data</span><br><span class="line">            </span><br><span class="line">    # 展示链表</span><br><span class="line">    def show(self):</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            print &apos;lkList is empty!&apos;</span><br><span class="line">        else:</span><br><span class="line">            p = self.top</span><br><span class="line">            for i in range(self.length):</span><br><span class="line">                print p.data</span><br><span class="line">                p = p.next</span><br></pre></td></tr></table></figure><hr><h2 id="栈的应用–四则运算表达式求值"><a href="#栈的应用–四则运算表达式求值" class="headerlink" title="栈的应用–四则运算表达式求值"></a>栈的应用–四则运算表达式求值</h2><h3 id="后缀（逆波兰）表示法"><a href="#后缀（逆波兰）表示法" class="headerlink" title="后缀（逆波兰）表示法"></a>后缀（逆波兰）表示法</h3><ul><li><p>中缀表示法：9+(3-1)*3+10/2</p></li><li><p>后缀表示法：9 3 1 - 3 * + 10 2 / +</p></li></ul><h3 id="中缀转后缀"><a href="#中缀转后缀" class="headerlink" title="中缀转后缀"></a>中缀转后缀</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"># Python 2.7</span><br><span class="line"></span><br><span class="line"># 将中缀字符串转换成数组</span><br><span class="line">def str2list(calc_str):</span><br><span class="line"># calc_str = &apos;9+(3-1)*3+10/2&apos;</span><br><span class="line">    symbol_list = [&apos;+&apos;, &apos;-&apos;, &apos;*&apos;, &apos;/&apos;, &apos;(&apos;, &apos;)&apos;]</span><br><span class="line">    calc_list = [calc_str]</span><br><span class="line">    for symbol in symbol_list:</span><br><span class="line">        str_list = []</span><br><span class="line">        for part in calc_list:</span><br><span class="line">            part_list = part.split(symbol)</span><br><span class="line">            temp = []</span><br><span class="line">            for item in part_list:</span><br><span class="line">                if item:  # 非空时追加</span><br><span class="line">                    temp.append(item)</span><br><span class="line">                temp.append(symbol)</span><br><span class="line">            del temp[-1]</span><br><span class="line">            if temp:  # 非空时追加</span><br><span class="line">                str_list.extend(temp)</span><br><span class="line">        calc_list = str_list</span><br><span class="line">    return calc_list</span><br><span class="line"></span><br><span class="line"># 中缀转后缀</span><br><span class="line">def mid_after(calc_str):    </span><br><span class="line">    mid2after = lkStack()</span><br><span class="line">    mid_list = str2list(calc_str)</span><br><span class="line">    after_list = []</span><br><span class="line">    symbol_list = [&apos;+&apos;, &apos;-&apos;, &apos;*&apos;, &apos;/&apos;, &apos;(&apos;, &apos;)&apos;]</span><br><span class="line">    symbol_value = &#123;&apos;(&apos;:-2, None:-1, &apos;+&apos;:0, &apos;-&apos;:0, &apos;*&apos;:1, &apos;/&apos;:1&#125;</span><br><span class="line">    for item in mid_list:</span><br><span class="line">        if item not in symbol_list:</span><br><span class="line">            after_list.append(item)</span><br><span class="line">        else:</span><br><span class="line">            if item == &apos;)&apos;:</span><br><span class="line">                while mid2after.top.data != &apos;(&apos;: </span><br><span class="line">                    top = mid2after.pop()</span><br><span class="line">                    after_list.append(top)</span><br><span class="line">                top = mid2after.pop()</span><br><span class="line">            else:</span><br><span class="line">                if item == &apos;(&apos;:</span><br><span class="line">                    mid2after.push(item)</span><br><span class="line">                else:</span><br><span class="line">                    if symbol_value[item] &gt; symbol_value[mid2after.top.data]:</span><br><span class="line">                        mid2after.push(item)</span><br><span class="line">                    if symbol_value[item] &lt; symbol_value[mid2after.top.data]:</span><br><span class="line">                        while symbol_value[item] &lt;= symbol_value[mid2after.top.data]:</span><br><span class="line">                            top = mid2after.pop()</span><br><span class="line">                            after_list.append(top)</span><br><span class="line">                        mid2after.push(item)</span><br><span class="line">    while not mid2after.is_empty():</span><br><span class="line">        top = mid2after.pop()</span><br><span class="line">        after_list.append(top)</span><br><span class="line">    return after_list</span><br></pre></td></tr></table></figure><h3 id="通过后缀表达式求值"><a href="#通过后缀表达式求值" class="headerlink" title="通过后缀表达式求值"></a>通过后缀表达式求值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Python 2.7</span><br><span class="line">  </span><br><span class="line">def after_calc(after_list):</span><br><span class="line">    symbol_list = [&apos;+&apos;, &apos;-&apos;, &apos;*&apos;, &apos;/&apos;]</span><br><span class="line">    stack = lkStack()</span><br><span class="line">    for item in after_list:</span><br><span class="line">        if item not in symbol_list:</span><br><span class="line">            stack.push(item)</span><br><span class="line">        else:</span><br><span class="line">            var1 = float(stack.pop())</span><br><span class="line">            var2 = float(stack.pop())</span><br><span class="line">            if item == &apos;+&apos;:</span><br><span class="line">                result = var2 + var1</span><br><span class="line">            elif item == &apos;-&apos;:</span><br><span class="line">                result = var2 - var1</span><br><span class="line">            elif item == &apos;*&apos;:</span><br><span class="line">                result = var2 * var1</span><br><span class="line">            else:</span><br><span class="line">                result = var2 / var1</span><br><span class="line">            stack.push(str(result))</span><br><span class="line">    return float(stack.top.data)</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Python 2.7</span><br><span class="line"></span><br><span class="line">calc_str = &apos;12+((12-7)*(11-2)-6)*12&apos;</span><br><span class="line">calc_list = str2list(calc_str)</span><br><span class="line">after_list = mid_after(calc_str)</span><br><span class="line">result = after_calc(after_list)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;顺序栈&quot;&gt;&lt;a href=&quot;#顺序栈&quot; class=&quot;headerlink&quot; title=&quot;顺序栈&quot;&gt;&lt;/a&gt;顺序栈&lt;/h2&gt;&lt;h3 id=&quot;三个基本属性&quot;&gt;&lt;a href=&quot;#三个基本属性&quot; class=&quot;headerlink&quot; title=&quot;三个基本属性&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="数据结构及算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构及算法--线性表</title>
    <link href="http://yoursite.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95--%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <id>http://yoursite.com/数据结构及算法--线性表/</id>
    <published>2018-04-08T01:00:00.000Z</published>
    <updated>2018-05-01T15:41:26.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="顺序线性表"><a href="#顺序线性表" class="headerlink" title="顺序线性表"></a>顺序线性表</h2><h3 id="三个基本属性"><a href="#三个基本属性" class="headerlink" title="三个基本属性"></a>三个基本属性</h3><ul><li><p>存储空间的起始位置data</p></li><li><p>线性表的最大存储量maxSize</p></li><li><p>线性表的当前长度length</p></li></ul><h3 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"># Python 2.7</span><br><span class="line"></span><br><span class="line">class seqList(object):</span><br><span class="line"></span><br><span class="line">    # 初始化</span><br><span class="line">    def __init__(self, maxSize):</span><br><span class="line">        self.data = [None] * maxSize</span><br><span class="line">        self.maxSize = maxSize</span><br><span class="line">        self.length = 0</span><br><span class="line">        </span><br><span class="line">    # 获取顺序表长度  </span><br><span class="line">    def getLength(self):</span><br><span class="line">        return self.length</span><br><span class="line">        </span><br><span class="line">    # 清空顺序表   </span><br><span class="line">    def clear(self):</span><br><span class="line">        for i in range(self.length):</span><br><span class="line">            self.data[i] = None</span><br><span class="line">        self.length = 0</span><br><span class="line">    </span><br><span class="line">    # 是否为空</span><br><span class="line">    def is_empty(self):</span><br><span class="line">        if self.length == 0:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br><span class="line">            </span><br><span class="line">    # 是否满</span><br><span class="line">    def is_full(self):</span><br><span class="line">        if self.length == self.maxSize:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br><span class="line">            </span><br><span class="line">    # 根据索引获得数据</span><br><span class="line">    def get_elem(self, index):</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            print &apos;seqList is empty!&apos;</span><br><span class="line">        if index &lt; 0 or index &gt; self.length - 1:</span><br><span class="line">            print &apos;position is error!&apos;</span><br><span class="line">        else:</span><br><span class="line">            return self.data[index]</span><br><span class="line">            </span><br><span class="line">    # 根据数据获得索引</span><br><span class="line">    def locate_elem(self, elem):</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            print &apos;seqList is empty!&apos;</span><br><span class="line">        else:</span><br><span class="line">            for i in range(self.length):</span><br><span class="line">                if self.data[i] == elem:</span><br><span class="line">                    return i</span><br><span class="line">            </span><br><span class="line">    # 追加数据</span><br><span class="line">    def append(self, elem):</span><br><span class="line">        if self.is_full():</span><br><span class="line">            print &apos;seqList is full!&apos;</span><br><span class="line">        else:</span><br><span class="line">            self.data[self.length] = elem</span><br><span class="line">            self.length += 1</span><br><span class="line">            </span><br><span class="line">    # 插入数据</span><br><span class="line">    def insert(self, index, elem):</span><br><span class="line">        if self.is_full():</span><br><span class="line">            print &apos;seqList is full!&apos;</span><br><span class="line">        else:</span><br><span class="line">            i = self.length</span><br><span class="line">            for item in self.data[self.length-1:index-1:-1]:</span><br><span class="line">                self.data[i] = item</span><br><span class="line">                i -= 1</span><br><span class="line">            self.data[index] = elem</span><br><span class="line">            self.length += 1</span><br><span class="line">            </span><br><span class="line">    # 删除元素</span><br><span class="line">    def delete(self, index):</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            print &apos;seqList is empty!&apos;</span><br><span class="line">        else:</span><br><span class="line">            if index &lt; 0 or index &gt; self.length-1:</span><br><span class="line">                print &apos;Position is error!&apos;</span><br><span class="line">            else:</span><br><span class="line">                for item in self.data[index+1:self.length]:</span><br><span class="line">                    self.data[index] = item</span><br><span class="line">                    index += 1</span><br><span class="line">                self.data[index] = None</span><br><span class="line">        self.length -= 1</span><br></pre></td></tr></table></figure><hr><h2 id="链式线性表"><a href="#链式线性表" class="headerlink" title="链式线性表"></a>链式线性表</h2><h3 id="节点的基本属性"><a href="#节点的基本属性" class="headerlink" title="节点的基本属性"></a>节点的基本属性</h3><ul><li><p>数据域data</p></li><li><p>后继指针next</p></li></ul><h3 id="链表的基本属性"><a href="#链表的基本属性" class="headerlink" title="链表的基本属性"></a>链表的基本属性</h3><ul><li><p>头结点</p></li><li><p>链表的长度</p></li></ul><h3 id="Python实现-1"><a href="#Python实现-1" class="headerlink" title="Python实现"></a>Python实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"># Python 2.7</span><br><span class="line"></span><br><span class="line"># 节点</span><br><span class="line">class Node(object):</span><br><span class="line">    def __init__(self, data, next=None):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.next = next</span><br><span class="line">        </span><br><span class="line"># 链表</span><br><span class="line">class lkList(object):</span><br><span class="line">    </span><br><span class="line">    # 初始化</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.head = Node(None)</span><br><span class="line">        self.length = 0</span><br><span class="line">        </span><br><span class="line">    # 是否为空</span><br><span class="line">    def is_empty(self):</span><br><span class="line">        if self.length == 0:</span><br><span class="line">            return True</span><br><span class="line">        else:</span><br><span class="line">            return False</span><br><span class="line">    </span><br><span class="line">    # 获取链表长度</span><br><span class="line">    def getLength(self):</span><br><span class="line">        return self.length</span><br><span class="line">        </span><br><span class="line">    # 插入元素</span><br><span class="line">    def insert(self, index, elem):</span><br><span class="line">        p = self.head</span><br><span class="line">        if index &lt; 0 or index &gt; self.length-1:</span><br><span class="line">            print &apos;Position is error!&apos;</span><br><span class="line">        else:</span><br><span class="line">            for i in range(index):</span><br><span class="line">                p = p.next</span><br><span class="line">            node = Node(elem, p.next)</span><br><span class="line">            p.next = node</span><br><span class="line">            self.length += 1</span><br><span class="line">            </span><br><span class="line">    # 追加元素</span><br><span class="line">    def append(self, elem):</span><br><span class="line">        p = self.head</span><br><span class="line">        for i in range(self.length):</span><br><span class="line">            p = p.next</span><br><span class="line">        node = Node(elem)</span><br><span class="line">        p.next = node</span><br><span class="line">        self.length += 1</span><br><span class="line">    </span><br><span class="line">    # 清空链表</span><br><span class="line">    def clear(self):</span><br><span class="line">        p = self.head</span><br><span class="line">        p.next = None</span><br><span class="line">        self.length = 0</span><br><span class="line">        </span><br><span class="line">    # 删除元素</span><br><span class="line">    def delete(self, index):</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            print &apos;lkList is empty!&apos;</span><br><span class="line">        else:</span><br><span class="line">            if index &lt; 0 or index &gt; self.length-1:</span><br><span class="line">                print &apos;Position is error!&apos;</span><br><span class="line">            else:</span><br><span class="line">                p = self.head</span><br><span class="line">                for i in range(index):</span><br><span class="line">                    p = p.next</span><br><span class="line">                q = p.next</span><br><span class="line">                p.next = q.next</span><br><span class="line">                self.length -= 1</span><br><span class="line">            </span><br><span class="line">    # 获取元素</span><br><span class="line">    def get_elem(self, index):</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            print &apos;lkList is empty!&apos;</span><br><span class="line">        else:</span><br><span class="line">            if index &lt; 0 or index &gt; self.length-1:</span><br><span class="line">                print &apos;Position is error!&apos;</span><br><span class="line">            else:</span><br><span class="line">                p = self.head</span><br><span class="line">                for i in range(index):</span><br><span class="line">                    p = p.next</span><br><span class="line">                return p.next.data</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">    # 查找某值的位置</span><br><span class="line">    def locate_elem(self, elem):</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            print &apos;lkList is empty!&apos;</span><br><span class="line">        else:</span><br><span class="line">            p = self.head</span><br><span class="line">            flag = False # 是否存在该值</span><br><span class="line">            for i in range(self.length):</span><br><span class="line">                p = p.next</span><br><span class="line">                if p.data == elem:</span><br><span class="line">                    flag = True</span><br><span class="line">                    return i</span><br><span class="line">            if not flag:</span><br><span class="line">                print &apos;elem not in lkList!&apos;</span><br><span class="line">                </span><br><span class="line">    # 构建链表</span><br><span class="line">    def create(self, dataList):</span><br><span class="line">        p = self.head</span><br><span class="line">        for item in dataList:</span><br><span class="line">            node = Node(item)</span><br><span class="line">            p.next = node</span><br><span class="line">            p = p.next</span><br><span class="line">            self.length += 1</span><br><span class="line">            </span><br><span class="line">    # 展示链表</span><br><span class="line">    def show(self):</span><br><span class="line">        if self.is_empty():</span><br><span class="line">            print &apos;lkList is empty!&apos;</span><br><span class="line">        else:</span><br><span class="line">            p = self.head</span><br><span class="line">            for i in range(self.length):</span><br><span class="line">                p = p.next</span><br><span class="line">                print p.data</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;顺序线性表&quot;&gt;&lt;a href=&quot;#顺序线性表&quot; class=&quot;headerlink&quot; title=&quot;顺序线性表&quot;&gt;&lt;/a&gt;顺序线性表&lt;/h2&gt;&lt;h3 id=&quot;三个基本属性&quot;&gt;&lt;a href=&quot;#三个基本属性&quot; class=&quot;headerlink&quot; title=&quot;三
      
    
    </summary>
    
      <category term="数据结构及算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数据结构及算法--二叉排序树</title>
    <link href="http://yoursite.com/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95--%E9%A1%BA%E5%BA%8F%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/数据结构及算法--顺序二叉树/</id>
    <published>2018-04-05T01:00:15.000Z</published>
    <updated>2018-04-30T12:10:38.351Z</updated>
    
    <content type="html"><![CDATA[<h2 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h2><blockquote><p> 二叉排序树，又称二叉查找树，其为空树，或具有以下性质的二叉树：</p></blockquote><ul><li>若其左子树不为空，则左子树上的所有节点的值均小于它的根结点的值；</li><li>若其右子树不为空，则右子树上的所有节点的值均大于它的根结点的值；</li><li>左右子树又分别是二叉排序树。</li></ul><p>作用：用于查找元素是否在某无序数组中。</p><p>如序列[62，58，88，47，73，99，35，51，93，29，37，49，56，36，48，50]，可构造二叉排序树如下：</p><p><img src="http://p3f66obex.bkt.clouddn.com/17-20170122120411444.dib" alt="这里写图片描述"></p><hr><h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Node:</span><br><span class="line">    def __init__(self, data):</span><br><span class="line">        self.data = data</span><br><span class="line">        self.lchild = None</span><br><span class="line">        self.rchild = None</span><br></pre></td></tr></table></figure><h3 id="搜索及插入"><a href="#搜索及插入" class="headerlink" title="搜索及插入"></a>搜索及插入</h3><p>当二叉排序树不为空时：</p><ul><li>将给定值与根结点的关键字比较，若相等，则查找成功；</li><li>若小于根结点的关键字值，递归查左子树；</li><li>若大于根结点的关键字值，递归查右子树；</li><li>若子树为空，查找不成功。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 搜索</span><br><span class="line">def search(self, node, parent, data):</span><br><span class="line">    if node is None:</span><br><span class="line">        return False, node, parent</span><br><span class="line">    if data == node.data:</span><br><span class="line">        return True, node, parent</span><br><span class="line">    if data &lt; node.data:</span><br><span class="line">        return self.search(node.lchild, node, data)</span><br><span class="line">    else:</span><br><span class="line">        return self.search(node.rchild, node, data)</span><br><span class="line"></span><br><span class="line"># 插入</span><br><span class="line">def insert(self, data):</span><br><span class="line">    flag, node, parent = self.search(self.root, self.root, data)</span><br><span class="line">    if not flag:</span><br><span class="line">        new_node = Node(data)</span><br><span class="line">        if data &gt; parent.data</span><br><span class="line">            parent.rchild = new_node</span><br><span class="line">        else:</span><br><span class="line">            parent.lchild = new_node</span><br></pre></td></tr></table></figure><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>删除操作主要分为以下3种情况：</p><ul><li>如果待删除的节点是叶子节点，那么可以立即被删除；</li><li>如果节点只有一个儿子，则将此节点parent的指针指向此节点的儿子，然后删除节点；</li><li>如果节点有两个儿子，则将其右子树的最小数据代替此节点的数据，并将其右子树的最小数据删除。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"># 删除</span><br><span class="line">def delete(self, root, data):</span><br><span class="line">    flag, n, p = self.search(root, root, data)</span><br><span class="line">    if not flag:</span><br><span class="line">        print &apos;无该关键字，删除失败！&apos;</span><br><span class="line">    else:</span><br><span class="line">        if n.lchild is None:</span><br><span class="line">            if n == p.lchild:</span><br><span class="line">                p.lchild = n.rchild</span><br><span class="line">            else:</span><br><span class="line">                p.rchild = n.rchild</span><br><span class="line">            del n</span><br><span class="line">        elif n.rchild is None:</span><br><span class="line">            if n == p.lchild:</span><br><span class="line">                p.lchild = n.lchild</span><br><span class="line">            else:</span><br><span class="line">                p.rchild = n.lchild</span><br><span class="line">            del n</span><br><span class="line">        else: # 左右子树均不为空</span><br><span class="line">            pre = n.rchild</span><br><span class="line">            if pre.lchild is None: # 若目标节点的右节点无左子树，则将目标节点替换为该节点</span><br><span class="line">                n.data = pre.data</span><br><span class="line">                n.rchild = pre.rchild</span><br><span class="line">                del pre</span><br><span class="line">            else: # 若目标节点的右节点有左子树，则往下搜索到达底部</span><br><span class="line">                next = pre.lchild</span><br><span class="line">                while next.lchild is not None:</span><br><span class="line">                    pre = next</span><br><span class="line">                    next = next.lchild</span><br><span class="line">                n.data = next.data</span><br><span class="line">                pre.lchild = next.rchild</span><br><span class="line">                del next</span><br></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>访问顺序如下：</p><ul><li>访问根节点</li><li>先序遍历左子树</li><li>先序遍历右子树</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 先序遍历</span><br><span class="line">def preOrderTraverse(self, node):</span><br><span class="line">    if node is None:</span><br><span class="line">        print node.data</span><br><span class="line">        self.preOrderTraverse(node.lchild)</span><br><span class="line">        self.preOrderTraverse(node.rchild)</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>访问顺序如下：</p><ul><li>中序遍历左子树</li><li>访问根节点</li><li>中序遍历右子树</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 中序遍历</span><br><span class="line">def inOrderTraverse(self, node):</span><br><span class="line">    if node is None:</span><br><span class="line">        self.inOrderTraverse(node.lchild)</span><br><span class="line">        print node.data</span><br><span class="line">        self.inOrderTraverse(node.rchild)</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>访问顺序如下：</p><ul><li>后序遍历左子树</li><li>后序遍历右子树</li><li>访问根节点 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 后序遍历</span><br><span class="line">def postOrderTraverse(self, node):</span><br><span class="line">    if node is None:</span><br><span class="line">        self.postOrderTraverse(node.lchild)</span><br><span class="line">        self.postOrderTraverse(node.rchild)</span><br><span class="line">        print node.data</span><br></pre></td></tr></table></figure><p>详细代码可见<a href="https://github.com/Ruanshubin/dataStructures_Algorithms/blob/master/数据结构及算法--二叉排序树/BST.py" target="_blank" rel="noopener">我的GitHub</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;性质&quot;&gt;&lt;a href=&quot;#性质&quot; class=&quot;headerlink&quot; title=&quot;性质&quot;&gt;&lt;/a&gt;性质&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt; 二叉排序树，又称二叉查找树，其为空树，或具有以下性质的二叉树：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;
      
    
    </summary>
    
      <category term="数据结构及算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Python网络爬虫--历史天气数据采集</title>
    <link href="http://yoursite.com/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB--%E5%8E%86%E5%8F%B2%E5%A4%A9%E6%B0%94%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86/"/>
    <id>http://yoursite.com/Python网络爬虫--历史天气数据采集/</id>
    <published>2018-03-28T14:00:16.000Z</published>
    <updated>2018-04-05T14:27:20.250Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在很多机器学习应用中，天气数据为重要的辅助特征数据，故本文主要介绍如何利用Python获取历史天气数据。</p></blockquote><h2 id="目标网站"><a href="#目标网站" class="headerlink" title="目标网站"></a>目标网站</h2><p>数据爬取的目标网站为<a href="http://lishi.tianqi.com/" target="_blank" rel="noopener">天气网</a></p><p><img src="http://p3f66obex.bkt.clouddn.com/16-1.JPG" alt=""></p><h2 id="编程实现"><a href="#编程实现" class="headerlink" title="编程实现"></a>编程实现</h2><h3 id="导入相关包"><a href="#导入相关包" class="headerlink" title="导入相关包"></a>导入相关包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import requests  # 导入requests</span><br><span class="line">from bs4 import BeautifulSoup  # 导入bs4中的BeautifulSoup</span><br><span class="line">import os</span><br><span class="line">import re</span><br><span class="line">import csv</span><br><span class="line">import pandas as pd</span><br><span class="line">import numpy as np</span><br><span class="line">import time</span><br><span class="line">import json</span><br></pre></td></tr></table></figure><blockquote><p>下面以爬取北京市历史天气数据为例进行演示：</p></blockquote><h3 id="获取所有月份URL"><a href="#获取所有月份URL" class="headerlink" title="获取所有月份URL"></a>获取所有月份URL</h3><p>分析网页源代码可知，所有月份的URL在’tqtongji1’的div中。</p><p><img src="http://p3f66obex.bkt.clouddn.com/16-2.JPG" alt=""></p><p>实现代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def get_url(request_url):</span><br><span class="line">    html = requests.get(request_url).text</span><br><span class="line">    Soup = BeautifulSoup(html, &apos;lxml&apos;) # 解析文档</span><br><span class="line">    all_li = Soup.find(&apos;div&apos;, class_=&apos;tqtongji1&apos;).find_all(&apos;li&apos;)</span><br><span class="line">    url_list = []</span><br><span class="line">    for li in all_li:</span><br><span class="line">        url_list.append([li.get_text(), li.find(&apos;a&apos;)[&apos;href&apos;]])       </span><br><span class="line">    return url_list</span><br></pre></td></tr></table></figure><h3 id="获取某月份的历史天气数据"><a href="#获取某月份的历史天气数据" class="headerlink" title="获取某月份的历史天气数据"></a>获取某月份的历史天气数据</h3><p>获取到月份URL后，分析月份的页面源代码可知，历史天气数据在’tqtongji2’的div中。</p><p><img src="http://p3f66obex.bkt.clouddn.com/16-3.JPG" alt=""></p><p>源代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def get_month_weather(request_url, year_number, month_number):</span><br><span class="line">    # month_url = &apos;http://lishi.tianqi.com/beijing/201712.html&apos;</span><br><span class="line">    url_list = get_url(request_url)</span><br><span class="line">    for i in range(len(url_list)-1, -1, -1):</span><br><span class="line">        year_split = int(url_list[i][0].encode(&apos;utf-8&apos;)[:4])</span><br><span class="line">        month_split = int(url_list[i][0].encode(&apos;utf-8&apos;)[7:9])</span><br><span class="line">        if year_split == year_number and month_split == month_number:</span><br><span class="line">            month_url = url_list[i][1]</span><br><span class="line">    html = requests.get(month_url).text</span><br><span class="line">    Soup = BeautifulSoup(html, &apos;lxml&apos;) # 解析文档</span><br><span class="line">    all_ul = Soup.find(&apos;div&apos;, class_=&apos;tqtongji2&apos;).find_all(&apos;ul&apos;)</span><br><span class="line">    month_weather = []</span><br><span class="line">    for i in range(1, len(all_ul)):</span><br><span class="line">        ul = all_ul[i]</span><br><span class="line">        li_list = []</span><br><span class="line">        for li in ul.find_all(&apos;li&apos;):</span><br><span class="line">            li_list.append(li.get_text().encode(&apos;utf-8&apos;))</span><br><span class="line">        month_weather.append(li_list)</span><br><span class="line">    return month_weather</span><br></pre></td></tr></table></figure><h3 id="获取某年的历史天气数据"><a href="#获取某年的历史天气数据" class="headerlink" title="获取某年的历史天气数据"></a>获取某年的历史天气数据</h3><p>将各月份的数据汇总即可得到年历史天气数据。</p><p>源代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">def get_year_weather(request_url, year_number):</span><br><span class="line">    year_weather = []</span><br><span class="line">    for i in range(12):</span><br><span class="line">        month_weather = get_month_weather(request_url, year_number, i+1)</span><br><span class="line">        year_weather.extend(month_weather)</span><br><span class="line">        print &apos;第%d月天气数据采集完成，望您知悉！&apos;%(i+1)</span><br><span class="line">    col_name = [&apos;Date&apos;, &apos;Max_Tem&apos;, &apos;Min_Tem&apos;, &apos;Weather&apos;, &apos;Wind&apos;, &apos;Wind_Level&apos;]</span><br><span class="line">    result_df = pd.DataFrame(year_weather)</span><br><span class="line">    result_df.columns = col_name</span><br><span class="line">    # result_df.to_csv(&apos;year_weather.csv&apos;)</span><br><span class="line">    return result_df</span><br></pre></td></tr></table></figure><p>执行’result_df = get_year_weather(request_url, 2017)’，结果如下：</p><p><img src="http://p3f66obex.bkt.clouddn.com/16-4.JPG" alt=""></p><p>详细代码及说明可点击<a href="https://github.com/Ruanshubin/Web_Spider_Python/blob/master/Python网络爬虫-历史天气数据采集/get_history_weather.py" target="_blank" rel="noopener">我的GitHub</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;在很多机器学习应用中，天气数据为重要的辅助特征数据，故本文主要介绍如何利用Python获取历史天气数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;目标网站&quot;&gt;&lt;a href=&quot;#目标网站&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="网络爬虫" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Git教程--本地库提交到GitHub远程库</title>
    <link href="http://yoursite.com/Git%E6%95%99%E7%A8%8B--%E6%9C%AC%E5%9C%B0%E5%BA%93%E6%8F%90%E4%BA%A4%E5%88%B0GitHub%E8%BF%9C%E7%A8%8B%E5%BA%93/"/>
    <id>http://yoursite.com/Git教程--本地库提交到GitHub远程库/</id>
    <published>2018-03-27T14:00:16.000Z</published>
    <updated>2018-04-20T13:45:14.835Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git操作"><a href="#Git操作" class="headerlink" title="Git操作"></a>Git操作</h2><h3 id="安装Git客户端"><a href="#安装Git客户端" class="headerlink" title="安装Git客户端"></a>安装Git客户端</h3><p><a href="https://help.github.com/articles/set-up-git/" target="_blank" rel="noopener">客户端下载地址</a></p><h3 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h3><ul><li>打开Git Bash，键入以下配置信息。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;You Name&quot;</span><br><span class="line">git config --global user.email &quot;yourmail@server.com&quot;</span><br></pre></td></tr></table></figure><h3 id="初始化本地库"><a href="#初始化本地库" class="headerlink" title="初始化本地库"></a>初始化本地库</h3><ul><li>创建本地库文件夹并切换到该文件夹：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir MyGit</span><br><span class="line">cd MyGit</span><br></pre></td></tr></table></figure><ul><li>初始化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><ul><li>提交代码</li></ul><p>创建代码文件后，将本地文件添加到Git版本库中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add filename</span><br><span class="line">git commit -m &quot;First commit&quot;</span><br></pre></td></tr></table></figure><h2 id="Github配置"><a href="#Github配置" class="headerlink" title="Github配置"></a>Github配置</h2><h3 id="生成公开密钥"><a href="#生成公开密钥" class="headerlink" title="生成公开密钥"></a>生成公开密钥</h3><ul><li>注册GitHub账号后，打开Git Bash，键入以下命令生成公开密钥。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -C &apos;yourmail@server.com&apos; -t rsa</span><br></pre></td></tr></table></figure><p>一路回车即可以，然后会在C:\Users\你的Windows用户名\目录下出现.ssh文件夹，包含id_rsa和id_rsa.pub两个文件，其中id_rsa.pub即为公开密钥，用Notepad++打开，复制其中内容；</p><h3 id="GitHub上设置公开密钥"><a href="#GitHub上设置公开密钥" class="headerlink" title="GitHub上设置公开密钥"></a>GitHub上设置公开密钥</h3><p>回到 GitHub 个人首页，点击 Account Settings -&gt; SSH and GPG key -&gt; New SSH key。title 可以随便取名字，Key 里面添加的内容为 id_rsa.pub 文件内所有的代码，然后点击 Apply 即可。</p><h3 id="测试与GitHub是否连接成功"><a href="#测试与GitHub是否连接成功" class="headerlink" title="测试与GitHub是否连接成功"></a>测试与GitHub是否连接成功</h3><ul><li>打开Git Bash，键入以下代码：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><p>若返回以下内容，则说明连接成功。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hi Your Name! You&apos;ve successfully authenticated, but GitHub does not provide shell access.</span><br></pre></td></tr></table></figure><h2 id="推送项目文件至GitHub"><a href="#推送项目文件至GitHub" class="headerlink" title="推送项目文件至GitHub"></a>推送项目文件至GitHub</h2><ul><li>打开Git Bash，键入以下代码：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin git@github.com:youusername/MyGit.git</span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><p>推送成功后，即可在GitHub上看到Push上的项目文件。</p><p>若出现以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal: remote origin already exists.</span><br></pre></td></tr></table></figure><p>则执行以下代码后，再执行上述代码即可解决上述问题。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Git操作&quot;&gt;&lt;a href=&quot;#Git操作&quot; class=&quot;headerlink&quot; title=&quot;Git操作&quot;&gt;&lt;/a&gt;Git操作&lt;/h2&gt;&lt;h3 id=&quot;安装Git客户端&quot;&gt;&lt;a href=&quot;#安装Git客户端&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="Git" scheme="http://yoursite.com/categories/Git/"/>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
      <category term="版本控制" scheme="http://yoursite.com/tags/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Python网络爬虫--模拟登陆教务处网站</title>
    <link href="http://yoursite.com/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB--%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86%E6%95%99%E5%8A%A1%E5%A4%84%E7%BD%91%E7%AB%99/"/>
    <id>http://yoursite.com/Python网络爬虫--模拟登陆教务处网站/</id>
    <published>2018-03-26T14:00:16.000Z</published>
    <updated>2018-04-05T14:14:23.802Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要介绍如何利用Python的requests库实现学校教务处网站的模拟登陆。关于教务处网站模拟登陆的典型应用主要有课程格子、超级课程表等，教务处网站形式多种多样，但登陆的基本流程类似，即构建表单-提交表单-实现登陆。本文以我浙的教务处网站为例进行模拟登陆演示。</p></blockquote><h2 id="登陆流程分析"><a href="#登陆流程分析" class="headerlink" title="登陆流程分析"></a>登陆流程分析</h2><p>首先打开我浙的教务处网站首页，F12打开开发者工具，输入学号、用户名、验证码，点击登陆之后，通过开发者工具可以看到，登陆过程包含3次请求，其中2次为暂时重定向(请求返回值为302代表暂时重定向)。</p><p><img src="http://p3f66obex.bkt.clouddn.com/14-1.JPG" alt=""></p><h3 id="表单分析"><a href="#表单分析" class="headerlink" title="表单分析"></a>表单分析</h3><p>点击’Headers’,如下图所示，易得第一次请求为表单提交(POST提交)。</p><p><img src="http://p3f66obex.bkt.clouddn.com/14-2.JPG" alt=""></p><p>提交的表单如下：</p><p><img src="http://p3f66obex.bkt.clouddn.com/14-3.JPG" alt=""></p><p>其中username, password, authcode分别为学号、密码和验证码，后面的lt, execution, _eventld为表单隐藏值，表单隐藏值是反爬虫的初级手段，那么如何获取表单隐藏值呢？</p><h3 id="获取表单隐藏值"><a href="#获取表单隐藏值" class="headerlink" title="获取表单隐藏值"></a>获取表单隐藏值</h3><p>表单隐藏值可以在实际登陆前，通过登陆界面表单填写部分的HTML代码获取，由下图所示：</p><p><img src="http://p3f66obex.bkt.clouddn.com/14-4.JPG" alt=""></p><p>可以看到，在登陆按钮的HTML源代码部分有3项隐藏的Input，观察name和value值，显然就是第一次请求POST的表单隐藏值。</p><h3 id="获取3次请求的网址"><a href="#获取3次请求的网址" class="headerlink" title="获取3次请求的网址"></a>获取3次请求的网址</h3><ul><li><p>第一次请求的网址为固定的，即’<a href="https://grs.zju.edu.cn/cas/login?locale=zh_CN&amp;service=http%3A%2F%2Fgrs.zju.edu.cn%2Fallogene%2Fpage%2Fhome.htm%3Flocale=zh_CN&#39;；" target="_blank" rel="noopener">https://grs.zju.edu.cn/cas/login?locale=zh_CN&amp;service=http%3A%2F%2Fgrs.zju.edu.cn%2Fallogene%2Fpage%2Fhome.htm%3Flocale=zh_CN&#39;；</a></p></li><li><p>按照上述分析构造表单，模拟POST请求，返回的’Response Headers’的Location即为第二次请求的网址；</p></li></ul><p><img src="http://p3f66obex.bkt.clouddn.com/14-5.JPG" alt=""></p><p>同样的方式获取第三次请求的网址；</p><p><img src="http://p3f66obex.bkt.clouddn.com/14-6.JPG" alt=""></p><p>访问第3次请求的网址，即可实现登陆，返回登陆之后的HTML代码。</p><p><img src="http://p3f66obex.bkt.clouddn.com/14-7.JPG" alt=""></p><h2 id="代码实现-Python2-7"><a href="#代码实现-Python2-7" class="headerlink" title="代码实现(Python2.7)"></a>代码实现(Python2.7)</h2><h3 id="导入相关包"><a href="#导入相关包" class="headerlink" title="导入相关包"></a>导入相关包</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import requests  # 导入requests</span><br><span class="line">import os</span><br><span class="line">from bs4 import BeautifulSoup  # 导入bs4中的BeautifulSoup</span><br><span class="line">import time</span><br><span class="line">from PIL import Image</span><br></pre></td></tr></table></figure><h3 id="实现第一次请求"><a href="#实现第一次请求" class="headerlink" title="实现第一次请求"></a>实现第一次请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">log_url = &apos;https://grs.zju.edu.cn/cas/login?locale=zh_CN&amp;service=http%3A%2F%2Fgrs.zju.edu.cn%2Fallogene%2Fpage%2Fhome.htm%3Flocale=zh_CN&apos;</span><br><span class="line">log_headers = &#123;&apos;Accept&apos;:&apos;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8&apos;,</span><br><span class="line">               &apos;Accept-Encoding&apos;:&apos;gzip, deflate, sdch&apos;,</span><br><span class="line">               &apos;Accept-Language&apos;:&apos;zh-CN,zh;q=0.8&apos;,</span><br><span class="line">               &apos;Cache-Control&apos;:&apos;max-age=0&apos;,</span><br><span class="line">               &apos;Connection&apos;:&apos;keep-alive&apos;,</span><br><span class="line">               &apos;Host&apos;:&apos;grs.zju.edu.cn&apos;,</span><br><span class="line">               &apos;Upgrade-Insecure-Requests&apos;:&apos;1&apos;,</span><br><span class="line">               &apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/49.0.2623.221 Safari/537.36 SE 2.X MetaSr 1.0&apos;             </span><br><span class="line">               &#125;</span><br><span class="line">session = requests.Session()</span><br><span class="line">log_html = session.get(url = log_url, headers = log_headers).text</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是：在访问的过程中，因为涉及多次请求，一定要通过Session()的方式来保持网站的对话。</p></blockquote><p>log_html为访问教务处网站主页返回的html文档，HTML文档的解析包挺多的，这里我们选用BeautifulSoup来解析返回文档，获取表单隐藏值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">log_Soup = BeautifulSoup(log_html, &apos;lxml&apos;)</span><br><span class="line">submit_list = log_Soup.find(&apos;li&apos;, class_=&apos;mt10 pl10&apos;).find_all(&apos;input&apos;)</span><br><span class="line">item_list = []</span><br><span class="line">for input_item in submit_list:</span><br><span class="line">    item_list.append([input_item[&apos;name&apos;], input_item[&apos;value&apos;]])</span><br><span class="line">log_data = dict(item_list)</span><br></pre></td></tr></table></figure><p>获取验证码图片，进行验证码识别，验证码识别可以采用OCR方式或者机器学习的方法，这里我们简化一下，直接采用手动输入的方式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 获取验证码</span><br><span class="line">auth_jpg_url = &apos;https://grs.zju.edu.cn/cas/Kaptcha.jpg&apos;</span><br><span class="line">picture = session.get(url = auth_jpg_url, headers = log_headers).content</span><br><span class="line">auth_jpg = open(&apos;Kaptcha.jpg&apos;, &apos;wb&apos;)</span><br><span class="line">auth_jpg.write(picture)</span><br><span class="line">auth_jpg.close()</span><br><span class="line"></span><br><span class="line"># 展示验证码</span><br><span class="line">log_img = Image.open(&apos;Kaptcha.jpg&apos;)</span><br><span class="line">log_img.show()</span><br><span class="line"></span><br><span class="line"># 输入验证码</span><br><span class="line">authcode = raw_input(&apos;Please input authcode: &apos;)</span><br><span class="line">log_data[&apos;authcode&apos;] = authcode</span><br></pre></td></tr></table></figure><p>构建好表单后，即可实现第一次请求：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">data = &#123;&apos;username&apos;:&apos;******&apos;,               </span><br><span class="line">        &apos;password&apos;:&apos;******&apos;,               </span><br><span class="line">        &apos;authcode&apos;:log_data[&apos;authcode&apos;],</span><br><span class="line">        &apos;submit&apos;:&apos;&apos;,</span><br><span class="line">        &apos;lt&apos;:log_data[&apos;lt&apos;],</span><br><span class="line">        &apos;execution&apos;:log_data[&apos;execution&apos;],</span><br><span class="line">        &apos;_eventId&apos;:log_data[&apos;_eventId&apos;]</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"># 实际登陆</span><br><span class="line">response = session.post(url = log_url, data = data, headers = log_headers, allow_redirects=False)</span><br><span class="line">response_headers = dict(response.headers)</span><br><span class="line">cookies = response.cookies.get_dict() # 用于第一次重定向</span><br></pre></td></tr></table></figure><p><strong> 需要注意保存每一次请求的cookies，以保持登陆状态。 </strong></p><h3 id="第二次请求"><a href="#第二次请求" class="headerlink" title="第二次请求"></a>第二次请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 第一次重定向</span><br><span class="line">home_first_url = response_headers[&apos;Location&apos;]</span><br><span class="line"># session_1 = requests.Session()</span><br><span class="line">response_1 = session.get(url = home_first_url, headers = log_headers, cookies = cookies, allow_redirects=False)</span><br><span class="line">response_headers_1 = dict(response_1.headers)</span><br><span class="line">cookies_1 = response_1.cookies.get_dict() # 用于第二次重定向</span><br></pre></td></tr></table></figure><h3 id="第三次请求"><a href="#第三次请求" class="headerlink" title="第三次请求"></a>第三次请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 第二次重定向</span><br><span class="line">home_second_url = response_headers_1[&apos;Location&apos;]</span><br><span class="line">response_2 = session.get(url = home_second_url, headers = log_headers, cookies = cookies_1)</span><br><span class="line">cookies_2 = response_2.cookies.get_dict()</span><br><span class="line">final_html = response_2.text # 登陆之后返回的html文档</span><br></pre></td></tr></table></figure><p>至此，大功告成，成功登陆教务处网站。</p><p>下面就可以做一些有意思的事情了，比如利用flask封装一个API接口，进而做出课程表查询、考试提醒、成绩查询等各种功能型应用。</p><blockquote><p>详细代码及说明可点击<a href="https://github.com/Ruanshubin/Web_Spider_Python/blob/master/Python网络爬虫-模拟登陆教务处网站/student_login.py" target="_blank" rel="noopener">我的GitHub</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文主要介绍如何利用Python的requests库实现学校教务处网站的模拟登陆。关于教务处网站模拟登陆的典型应用主要有课程格子、超级课程表等，教务处网站形式多种多样，但登陆的基本流程类似，即构建表单-提交表单-实现登陆。本文以我浙的教务处网站为例
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="网络爬虫" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Python网络爬虫--利用pytesseract进行网站验证码识别</title>
    <link href="http://yoursite.com/Python%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB--%E5%88%A9%E7%94%A8pytesseract%E8%BF%9B%E8%A1%8C%E7%BD%91%E7%AB%99%E9%AA%8C%E8%AF%81%E7%A0%81%E8%AF%86%E5%88%AB/"/>
    <id>http://yoursite.com/Python网络爬虫--利用pytesseract进行网站验证码识别/</id>
    <published>2018-03-25T14:00:16.000Z</published>
    <updated>2018-04-05T14:04:34.476Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Python-tesseract是一个基于google’s Tesseract-OCR的独立封装包；<br>Python-tesseract功能是识别图片文件中文字，并作为返回参数返回识别结果；<br>Python-tesseract默认支持tiff、bmp格式图片，只有在安装PIL之后，才能支持jpeg、gif、png等其他图片格式。</p></blockquote><h2 id="安装PIL及pytesseract"><a href="#安装PIL及pytesseract" class="headerlink" title="安装PIL及pytesseract"></a>安装PIL及pytesseract</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install PIL, pytesseract</span><br></pre></td></tr></table></figure><h2 id="安装tesseract-OCR软件"><a href="#安装tesseract-OCR软件" class="headerlink" title="安装tesseract-OCR软件"></a>安装tesseract-OCR软件</h2><blockquote><p>pytesseract实际上调用的是tesseract-OCR的内部函数，故在进行网站验证码识别时，需提前安装好tesseract-OCR软件。</p></blockquote><h3 id="安装包下载"><a href="#安装包下载" class="headerlink" title="安装包下载"></a>安装包下载</h3><p><a href="http://digi.bib.uni-mannheim.de/tesseract/tesseract-ocr-setup-4.00.00dev.exe" target="_blank" rel="noopener">安装包地址</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>执行默认安装即可，需要记住安装目录，以便于后面配置环境变量。</p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>控制面板-系统-高级系统设置-环境变量-系统变量</p><p>‘Path’-新建-将tesseract-OCR安装目录添加进去，如’C:\Program Files (x86)\Tesseract-OCR’</p><p><img src="http://p3f66obex.bkt.clouddn.com/13-1.JPG" alt=""></p><p>cmd打开命令提示符界面，输入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tesseract -v</span><br></pre></td></tr></table></figure><p>可以看到版本信息。</p><p><img src="http://p3f66obex.bkt.clouddn.com/13-2.JPG" alt=""></p><h2 id="网站验证码识别"><a href="#网站验证码识别" class="headerlink" title="网站验证码识别"></a>网站验证码识别</h2><h3 id="在源代码中设置训练数据集的路径"><a href="#在源代码中设置训练数据集的路径" class="headerlink" title="在源代码中设置训练数据集的路径"></a>在源代码中设置训练数据集的路径</h3><p>修改pytesseract.py，否则会报错：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pytesseract.pytesseract.TesseractError: (1, &apos;Error opening data file \\Program Files (x86)\\Tesseract-OCR\\eng.traineddata&apos;)</span><br></pre></td></tr></table></figure><p>修改部分如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 添加下面这行</span><br><span class="line">my_env = &#123;&quot;TESSDATA_PREFIX&quot;:r&quot;C:\Program Files (x86)\Tesseract-OCR\tessdata&quot;&#125;</span><br><span class="line"></span><br><span class="line">if lang is not None:</span><br><span class="line">    command += (&apos;-l&apos;, lang)</span><br><span class="line"></span><br><span class="line">command += shlex.split(config)</span><br><span class="line"></span><br><span class="line">if extension != &apos;box&apos;:</span><br><span class="line">    command.append(extension)</span><br><span class="line"></span><br><span class="line"># 添加参数env = my_env</span><br><span class="line">proc = subprocess.Popen(command, env = my_env, stderr=subprocess.PIPE)</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试图片如下：</p><p><img src="http://p3f66obex.bkt.clouddn.com/13-3.jpg" alt=""></p><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">import pytesseract</span><br><span class="line"></span><br><span class="line">img = Image.open(&apos;7025.jpg&apos;)</span><br><span class="line">print (pytesseract.image_to_string(img))</span><br></pre></td></tr></table></figure><p><img src="http://p3f66obex.bkt.clouddn.com/13-5.JPG" alt=""></p><p>可以看出，识别结果有误，故需要对图片进行预处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">from PIL import Image</span><br><span class="line">import pytesseract</span><br><span class="line"></span><br><span class="line">def power_img(img_name):</span><br><span class="line">    image = Image.open(img_name)</span><br><span class="line">    imgry = image.convert(&apos;L&apos;)</span><br><span class="line">    imgry.save(&apos;g&apos; + img_name)  # 保存灰度图</span><br><span class="line">    # 二值化</span><br><span class="line">    threshold = 140</span><br><span class="line">    table = []</span><br><span class="line">    for i in range(256):</span><br><span class="line">        if i &lt; threshold:</span><br><span class="line">            table.append(0)</span><br><span class="line">        else:</span><br><span class="line">            table.append(1)</span><br><span class="line">    out = imgry.point(table, &apos;1&apos;)</span><br><span class="line">    out.save(&apos;b&apos; + img_name)</span><br><span class="line">    return out</span><br><span class="line">    </span><br><span class="line">img = power_img(&apos;7025.jpg&apos;)</span><br><span class="line">print (pytesseract.image_to_string(img))</span><br></pre></td></tr></table></figure><p>处理后的图片如下：</p><p><img src="http://p3f66obex.bkt.clouddn.com/13-4.jpg" alt=""></p><p>此时，识别结果正确。</p><p><img src="http://p3f66obex.bkt.clouddn.com/13-6.JPG" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Python-tesseract是一个基于google’s Tesseract-OCR的独立封装包；&lt;br&gt;Python-tesseract功能是识别图片文件中文字，并作为返回参数返回识别结果；&lt;br&gt;Python-tesseract默认支持tif
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
      <category term="网络爬虫" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>Linux教程6--Vim程序编辑器</title>
    <link href="http://yoursite.com/Linux%E6%95%99%E7%A8%8B6--Vim%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>http://yoursite.com/Linux教程6--Vim程序编辑器/</id>
    <published>2018-03-23T14:00:16.000Z</published>
    <updated>2018-04-05T14:29:22.362Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为Linux系列教程的第1篇，主要讲解主机规划和磁盘分区，参考书籍为<a href="http://linux.vbird.org/" target="_blank" rel="noopener">鸟哥的Linux私房菜</a>。</p></blockquote><h2 id="vi和vim"><a href="#vi和vim" class="headerlink" title="vi和vim"></a>vi和vim</h2><h3 id="vi的优点"><a href="#vi的优点" class="headerlink" title="vi的优点"></a>vi的优点</h3><ul><li>所有UNIX Like系统均会内置vi文本编辑器；</li><li>软件的编辑接口均会主动调用vi；</li><li>Vim均有程序编辑的能力；</li><li>程序简单，编辑速度相当快速。</li></ul><h3 id="Vi的使用"><a href="#Vi的使用" class="headerlink" title="Vi的使用"></a>Vi的使用</h3><p>vi分为3种模式：一般模式、编辑模式、命令行模式；<br>[Esc]键退出编辑模式。</p><h3 id="简单执行范例"><a href="#简单执行范例" class="headerlink" title="简单执行范例"></a>简单执行范例</h3><ul><li>使用vi进入一般模式；</li><li>按下i进入编辑模式，开始编辑文字；</li><li>按下[Esc]键回到一般模式；</li><li>在一般模式中输入“:wq”保存后离开vi。</li></ul><hr><h2 id="按键说明"><a href="#按键说明" class="headerlink" title="按键说明"></a>按键说明</h2><h3 id="一般模式"><a href="#一般模式" class="headerlink" title="一般模式"></a>一般模式</h3><blockquote><p>移动光标的方法</p></blockquote><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">功能说明</th></tr></thead><tbody><tr><td style="text-align:center">h或左箭头键</td><td style="text-align:center">光标左移动1个字符</td></tr><tr><td style="text-align:center">j或向下箭头键</td><td style="text-align:center">光标下移动1个字符</td></tr><tr><td style="text-align:center">k或向上箭头键</td><td style="text-align:center">光标上移动1个字符</td></tr><tr><td style="text-align:center">l或右箭头键</td><td style="text-align:center">光标右移动1个字符</td></tr><tr><td style="text-align:center">组合键：30j</td><td style="text-align:center">向下30行。</td></tr><tr><td style="text-align:center">[Ctrl] + [f]</td><td style="text-align:center">向下移动1页</td></tr><tr><td style="text-align:center">[Ctrl] + [b]</td><td style="text-align:center">向上移动1页</td></tr><tr><td style="text-align:center">[Ctrl] + [d]</td><td style="text-align:center">向下移动半页</td></tr><tr><td style="text-align:center">[Ctrl] + [u]</td><td style="text-align:center">向上移动半页</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">光标移动到非空格符的下一行</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">光标移动到非空格符的上一行</td></tr><tr><td style="text-align:center">n</td><td style="text-align:center">向后移动n个字符</td></tr><tr><td style="text-align:center">数字0或[Home]</td><td style="text-align:center">移动到行首</td></tr><tr><td style="text-align:center">$或功能键[End]</td><td style="text-align:center">移动到行末</td></tr><tr><td style="text-align:center">H</td><td style="text-align:center">屏幕最上方1行第一个字符</td></tr><tr><td style="text-align:center">M</td><td style="text-align:center">屏幕中间1行第一个字符</td></tr><tr><td style="text-align:center">L</td><td style="text-align:center">屏幕最下方1行第一个字符</td></tr><tr><td style="text-align:center">G</td><td style="text-align:center">文件的最后1行</td></tr><tr><td style="text-align:center">nG</td><td style="text-align:center">移动到文件的第n行（配合:set nu）</td></tr><tr><td style="text-align:center">gg</td><td style="text-align:center">文件的第1行</td></tr><tr><td style="text-align:center">n[Enter]</td><td style="text-align:center">向下移动n行</td></tr></tbody></table><blockquote><p>查找和替换</p></blockquote><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">功能说明</th></tr></thead><tbody><tr><td style="text-align:center">/word</td><td style="text-align:center">向下查找word的字符串</td></tr><tr><td style="text-align:center">?word</td><td style="text-align:center">向上查找word的字符串</td></tr><tr><td style="text-align:center">n</td><td style="text-align:center">重复上一个操作</td></tr><tr><td style="text-align:center">N</td><td style="text-align:center">反向上一个操作</td></tr><tr><td style="text-align:center">:n1,n2s/word1/word2/g</td><td style="text-align:center">n1和n2行之间搜索word1，并替换为word2</td></tr><tr><td style="text-align:center">:1,$s/word1/word2/g</td><td style="text-align:center">第1行和最后1行之间搜索word1，并替换为word2。</td></tr><tr><td style="text-align:center">:1,$s/word1/word2/gc</td><td style="text-align:center">第1行和最后1行之间搜索word1，并替换为word2，询问确认。</td></tr></tbody></table><blockquote><p>删除、复制与粘贴</p></blockquote><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">功能说明</th></tr></thead><tbody><tr><td style="text-align:center">x</td><td style="text-align:center">向后删除1个字符</td></tr><tr><td style="text-align:center">X</td><td style="text-align:center">向前删除1个字符</td></tr><tr><td style="text-align:center">nx</td><td style="text-align:center">连续往后删除n个字符</td></tr><tr><td style="text-align:center">dd</td><td style="text-align:center">删除光标所在行</td></tr><tr><td style="text-align:center">ndd</td><td style="text-align:center">删除光标向下n行</td></tr><tr><td style="text-align:center">d1G</td><td style="text-align:center">删除光标所在行到第1行的数据</td></tr><tr><td style="text-align:center">dG</td><td style="text-align:center">删除光标所在行到最后1行的数据</td></tr><tr><td style="text-align:center">d$</td><td style="text-align:center">删除光标所在处到该行最后1个字符</td></tr><tr><td style="text-align:center">d0</td><td style="text-align:center">删除光标所在处到该行第1个字符</td></tr><tr><td style="text-align:center">yy</td><td style="text-align:center">复制光标所在行</td></tr><tr><td style="text-align:center">nyy</td><td style="text-align:center">复制光标所在向下n行</td></tr><tr><td style="text-align:center">y1G</td><td style="text-align:center">复制光标所在行到第1行的数据</td></tr><tr><td style="text-align:center">yG</td><td style="text-align:center">复制光标所在行到最后1行的数据</td></tr><tr><td style="text-align:center">y$</td><td style="text-align:center">复制光标所在处到该行最后1个字符</td></tr><tr><td style="text-align:center">y0</td><td style="text-align:center">复制光标所在处到该行第1个字符</td></tr><tr><td style="text-align:center">p</td><td style="text-align:center">光标下1行粘贴</td></tr><tr><td style="text-align:center">P</td><td style="text-align:center">光标上1行粘贴</td></tr><tr><td style="text-align:center">J</td><td style="text-align:center">光标所在行与下一行合并</td></tr><tr><td style="text-align:center">u</td><td style="text-align:center">复原上一个操作</td></tr><tr><td style="text-align:center">[Ctrl]+r</td><td style="text-align:center">重做上一个操作</td></tr></tbody></table><h3 id="编辑模式"><a href="#编辑模式" class="headerlink" title="编辑模式"></a>编辑模式</h3><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">功能说明</th></tr></thead><tbody><tr><td style="text-align:center">i</td><td style="text-align:center">当前光标所在处插入</td></tr><tr><td style="text-align:center">I</td><td style="text-align:center">当前行第一个非空字符处插入</td></tr><tr><td style="text-align:center">a</td><td style="text-align:center">当前光标下1个字符</td></tr><tr><td style="text-align:center">A</td><td style="text-align:center">当前行最后1个字符处插入</td></tr><tr><td style="text-align:center">o</td><td style="text-align:center">当前行下一行插入新行</td></tr><tr><td style="text-align:center">O</td><td style="text-align:center">当前行上一行插入新行</td></tr><tr><td style="text-align:center">r</td><td style="text-align:center">进入替换模式，当前光标1次</td></tr><tr><td style="text-align:center">R</td><td style="text-align:center">进入替换模式，当前光标多次</td></tr><tr><td style="text-align:center">[Esc]</td><td style="text-align:center">退出编辑模式</td></tr></tbody></table><h3 id="命令行模式"><a href="#命令行模式" class="headerlink" title="命令行模式"></a>命令行模式</h3><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">功能说明</th></tr></thead><tbody><tr><td style="text-align:center">:w</td><td style="text-align:center">保存</td></tr><tr><td style="text-align:center">:w!</td><td style="text-align:center">强制保存</td></tr><tr><td style="text-align:center">:q</td><td style="text-align:center">离开vi</td></tr><tr><td style="text-align:center">:q!</td><td style="text-align:center">强制离开</td></tr><tr><td style="text-align:center">:wq</td><td style="text-align:center">保存后离开</td></tr><tr><td style="text-align:center">ZZ</td><td style="text-align:center">文件不变，不保存离开；文件变化，保存后离开</td></tr><tr><td style="text-align:center">:w[filename]</td><td style="text-align:center">另存文件</td></tr><tr><td style="text-align:center">:r[filename]</td><td style="text-align:center">读入另一个文件的数据，追加到当前行后面</td></tr><tr><td style="text-align:center">:n1,n2 w [filename]</td><td style="text-align:center">n1到n2行之间内容保存到某个文件</td></tr><tr><td style="text-align:center">:! command</td><td style="text-align:center">暂时离开vi到命令行模式下执行command的显示结果</td></tr><tr><td style="text-align:center">:set nu</td><td style="text-align:center">显示行号</td></tr><tr><td style="text-align:center">:set nonu</td><td style="text-align:center">取消行号</td></tr></tbody></table><p><strong>注意：数字通常代表重复做几次的意思。</strong></p><hr><h2 id="Vim的保存文件、恢复与打开时的警告信息"><a href="#Vim的保存文件、恢复与打开时的警告信息" class="headerlink" title="Vim的保存文件、恢复与打开时的警告信息"></a>Vim的保存文件、恢复与打开时的警告信息</h2><p>vim testvim.txt<br>[Ctrl]+z # 切换到后台；<br>——ls –al # 出现文件的暂存文件<br>Kill -9 %1 # 杀掉上一进程<br>vim testvim.txt # 此时会发生报错</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Swap file &quot;.testvim.txt.swp&quot; already exists!</span><br><span class="line">[O]pen Read-Only, (E)dit anyway, (R)ecover, (D)elete it, (Q)uit, (A)bort:</span><br></pre></td></tr></table></figure><ul><li>[O]pen Read-Only，打开此文件成为只读文件；</li><li>[E]dit anyway，正常方式打开编辑的文件，并不会载入暂存文件；</li><li>[R]ecover，加载暂存文件的内容，救回来之后需要手动删除暂存文件.testvim.txt.swp；</li><li>[D]elete it，将暂存文件删除；</li><li>[Q]uit，离开vim；</li><li>[A]bort，忽略这个编辑行为。</li></ul><hr><h2 id="块选择（Visual-Block）"><a href="#块选择（Visual-Block）" class="headerlink" title="块选择（Visual Block）"></a>块选择（Visual Block）</h2><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">功能说明</th></tr></thead><tbody><tr><td style="text-align:center">V</td><td style="text-align:center">光标经过的地方反白选择</td></tr><tr><td style="text-align:center">[Ctrl]+v</td><td style="text-align:center">块选择</td></tr><tr><td style="text-align:center">y</td><td style="text-align:center">将反白的地方复制</td></tr><tr><td style="text-align:center">d</td><td style="text-align:center">将反白的地方删除</td></tr></tbody></table><hr><h2 id="多文件、多窗口"><a href="#多文件、多窗口" class="headerlink" title="多文件、多窗口"></a>多文件、多窗口</h2><h3 id="多文件编辑"><a href="#多文件编辑" class="headerlink" title="多文件编辑"></a>多文件编辑</h3><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">功能说明</th></tr></thead><tbody><tr><td style="text-align:center">:n</td><td style="text-align:center">编辑下一个文件</td></tr><tr><td style="text-align:center">:N</td><td style="text-align:center">编辑上一个文件</td></tr><tr><td style="text-align:center">:files</td><td style="text-align:center">列出当前编辑的所有文件</td></tr></tbody></table><h3 id="多窗口编辑"><a href="#多窗口编辑" class="headerlink" title="多窗口编辑"></a>多窗口编辑</h3><blockquote><p>将一个大文件切分成多个窗口查看。</p></blockquote><table><thead><tr><th style="text-align:center">按键</th><th style="text-align:center">功能说明</th></tr></thead><tbody><tr><td style="text-align:center">:sp [filename]</td><td style="text-align:center">1.当前文件切分 :sp <br> 2.另外一个文件切分 :sp [filename]</td></tr><tr><td style="text-align:center">[Ctrl]+w+j <br> [Ctrl]+w+下箭头</td><td style="text-align:center">按住[Ctrl]不松，接着按w，松开后按方向切到下一个文件编辑</td></tr><tr><td style="text-align:center">[Ctrl]+w+k <br> [Ctrl]+w+上箭头</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center">[Ctrl]+w+q</td><td style="text-align:center">其实就是:q结束离开</td></tr></tbody></table><p><strong> 注意：语系编码转换使用iconv命令。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为Linux系列教程的第1篇，主要讲解主机规划和磁盘分区，参考书籍为&lt;a href=&quot;http://linux.vbird.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;鸟哥的Linux私房菜&lt;/a&gt;。&lt;/p&gt;
&lt;/
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux教程5--文件压缩及打包</title>
    <link href="http://yoursite.com/Linux%E6%95%99%E7%A8%8B5--%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%E5%8F%8A%E6%89%93%E5%8C%85/"/>
    <id>http://yoursite.com/Linux教程5--文件压缩及打包/</id>
    <published>2018-03-21T14:00:16.000Z</published>
    <updated>2018-04-05T14:29:08.611Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为Linux系列教程的第1篇，主要讲解主机规划和磁盘分区，参考书籍为<a href="http://linux.vbird.org/" target="_blank" rel="noopener">鸟哥的Linux私房菜</a>。</p></blockquote><h2 id="zip命令"><a href="#zip命令" class="headerlink" title="zip命令"></a>zip命令</h2><blockquote><p>zip –r myfile.zip ./*</p></blockquote><p>将当前目录下的所有文件和文件夹全部压缩成myfile.zip文件，-r代表递归压缩。</p><blockquote><p>unzip –o –d /home/sunny myfile.zip</p></blockquote><ul><li>-o：不提示的情况下覆盖文件；</li><li>-d：–d /home/sunny指明将文件解压到某目录。</li></ul><blockquote><p>zip –d myfile.zip smart.txt</p></blockquote><p>删除压缩文件中的smart.txt文件。</p><blockquote><p>zip –m myfile.zip ./rpm_info.txt</p></blockquote><p>向压缩文件myfile.zip中添加rpm_info.txt文件。</p><blockquote><p>zip –r filename.zip file1 file2 file3</p></blockquote><p>将file1 file2 file3目录压缩起来。</p><h2 id="tar命令"><a href="#tar命令" class="headerlink" title="tar命令"></a>tar命令</h2><blockquote><p>tar:</p></blockquote><ul><li>-c：建立压缩档案；</li><li>-x：解压；</li><li>-t：查看内容（列出文件）；</li><li>-r：向压缩归档文件末尾追加文件；</li><li>-u：更新原压缩包中的文件。</li></ul><p><strong> 上述5个参数只能选1个。</strong></p><ul><li>-f：使用档案名字，该参数是最后一个参数，后面只能接档案名。</li></ul><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar –cf all.tar *.jpg</span><br><span class="line">  将所有的.jpg文件打成一个all.tar包，-c产生新的包，-f指定包的文件名。</span><br><span class="line">tar –rf all.tar *.gif</span><br><span class="line">  将所有的.gif文件增加到all.tar包里面去。</span><br></pre></td></tr></table></figure><h3 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar –cvf jpg.tar *jpg   # 仅打包，不压缩</span><br><span class="line">tar –czf jpg.tar.gz *.jpg  # 将所有.jpg文件打包后，用gzip压缩</span><br><span class="line">tar –cjf jpg.tar.bz2 *.jpg  # 将所有.jpg文件打包后，用bzip2压缩</span><br><span class="line">tar –cjf jpg.tar.Z *.jpg  # 将所有.jpg文件打包后，用compress压缩</span><br><span class="line">rar a jpg.rar *.jpg</span><br><span class="line">zip jpg.zip *.jpg</span><br></pre></td></tr></table></figure><h3 id="解压"><a href="#解压" class="headerlink" title="解压"></a>解压</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar xvf jpg.tar  # 解压tar包</span><br><span class="line">tar xzvf jpg.tar.gz  # 解压tar.gz</span><br><span class="line">tar xjvf jpg.tar.bz2  # 解压tar.bz2</span><br><span class="line">tar xZvf jpg.tar.Z  # 解压tar.Z</span><br><span class="line">unrar e jpg.rar</span><br><span class="line">unzip jpg.zip</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为Linux系列教程的第1篇，主要讲解主机规划和磁盘分区，参考书籍为&lt;a href=&quot;http://linux.vbird.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;鸟哥的Linux私房菜&lt;/a&gt;。&lt;/p&gt;
&lt;/
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux教程4--磁盘与文件系统管理</title>
    <link href="http://yoursite.com/Linux%E6%95%99%E7%A8%8B4--%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/Linux教程4--磁盘与文件系统管理/</id>
    <published>2018-03-20T14:00:16.000Z</published>
    <updated>2018-04-05T14:28:54.751Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为Linux系列教程的第1篇，主要讲解主机规划和磁盘分区，参考书籍为<a href="http://linux.vbird.org/" target="_blank" rel="noopener">鸟哥的Linux私房菜</a>。</p></blockquote><h2 id="文件系统特性"><a href="#文件系统特性" class="headerlink" title="文件系统特性"></a>文件系统特性</h2><p>Linux文件系统通常会将文件的权限与属性放置到inode中，实际数据放置到data block中，另外还有一个超级块（super block）记录整个文件系统的整体信息。</p><ul><li>super block：</li></ul><p>记录此文件系统的整体信息，包括inode与block的总量、使用量、剩余量，以及文件系统的格式与相关信息等；</p><ul><li>inode:</li></ul><p>记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的block号码；</p><ul><li>block:</li></ul><p>实际记录文件的内容，若文件太大时，会占用多个block。假设某个文件的属性和权限数据放置在inode4，而这个inode记录的文件数据实际放置在2-7-13-15这4个block中，此时Linux系统能够据此来排列磁盘的阅读顺序，一次性将4个block内容读取出来，此种数据访问的方式我们称为索引式文件系统（indexed allocation）。与之对应的是FAT模式，它是链式的，每个block号码记录在上一个block中，相当于链表的读取方式，无inode。</p><h3 id="碎片整理"><a href="#碎片整理" class="headerlink" title="碎片整理"></a>碎片整理</h3><blockquote><p>需要碎片整理的原因是文件写入的block太过于离散了，此时文件的读取性能将会变得很差所致，这个时候需要通过碎片整理将同一个文件所属的block汇合在一起，这样数据的读取会比较容易，FAT的文件系统需要经常碎片整理一下，而Linux的Ext2文件系统由于是索引式的，基本上不太需要经常进行碎片整理。</p></blockquote><hr><h2 id="Linux的Ex2文件系统（inode）"><a href="#Linux的Ex2文件系统（inode）" class="headerlink" title="Linux的Ex2文件系统（inode）"></a>Linux的Ex2文件系统（inode）</h2><h3 id="Data-block（数据块）"><a href="#Data-block（数据块）" class="headerlink" title="Data block（数据块）"></a>Data block（数据块）</h3><p>在Ext2文件系统中所支持的block大小有1KB、2KB、4KB三种，其文件系统限制如下：</p><table><thead><tr><th style="text-align:center">Block大小</th><th style="text-align:center">1KB</th><th style="text-align:center">2KB</th><th style="text-align:center">4KB</th></tr></thead><tbody><tr><td style="text-align:center">最大单一文件限制</td><td style="text-align:center">16GB</td><td style="text-align:center">256GB</td><td style="text-align:center">2TB</td></tr><tr><td style="text-align:center">最大文件系统的容量</td><td style="text-align:center">2TB</td><td style="text-align:center">8TB</td><td style="text-align:center">16TB</td></tr></tbody></table><p>原则上，block的大小与数量在格式化完就不能够改变了（除非重新格式化）；</p><p>每个block内最多只能够放置一个文件的数据；</p><p>如果文件大于block的大小，则1个文件会占用多个block数量；</p><p>若文件小于block，则该block的剩余空间就不能够再使用了（磁盘空间会浪费）。</p><p><strong> 文件系统根据需求合理选择，block大了容易造成磁盘容量浪费，小了的话，大型文件会占用数量较多的block，inode需要记录太多的block，可能导致文件系统不良的读写性能。</strong></p><h3 id="inode（inode表格）"><a href="#inode（inode表格）" class="headerlink" title="inode（inode表格）"></a>inode（inode表格）</h3><blockquote><p>inode记录的文件数据至少包括：</p></blockquote><ul><li>该文件的访问模式（read/write/excute）;</li><li>该文件的所有者与组（owner/group）；</li><li>该文件的大小；</li><li>该文件创建或状态改变的时间（ctime）；</li><li>最近一次读取时间（atime）；</li><li>最近修改的时间（mtime）；</li><li>定义文件特性的标志（flag），如SetUID等；</li><li>该文件真正内容的指向（pointer）；</li></ul><blockquote><p>inode的特色：</p></blockquote><ul><li>每个inode大小固定为128Bytes；</li><li>每个文件均占用一个inode；</li><li>文件系统能够创建的文件数量与inode的数量有关；</li><li>inode记录一个block需要花费4Bytes。</li></ul><p>为记录大量的block，inode记录block号码的区域定义为12个直接、1个间接、1个二级间接、1个三级间接记录区。</p><blockquote><p>inode能够指定多少block呢？下面以1KB的block来说明：</p></blockquote><ul><li>12个直接指向：12*1K=12K；</li><li>1个间接指向：（1024/4）*1K=256K；</li><li>1个二级间接指向：（1024/4）（1024/4）1K=2562K</li><li>同理，1个三级间接指向：2563K</li></ul><p>总额：12+256+2562+2563（K）=16GB；与文件系统系统限制一致，此方法不能用于2KB及4KB的block计算中，因为这两者将会受到Ext2文件系统自身的限制，计算结果会不大符合。</p><h3 id="superblock（超级块）"><a href="#superblock（超级块）" class="headerlink" title="superblock（超级块）"></a>superblock（超级块）</h3><p>记录的信息如下：</p><ul><li>block与inode的总量；</li><li>未使用与已使用的inode/block量；</li><li>block与inode的大小（block：1K/2K/4K，inode：128Bytes）；</li><li>文件系统的挂载时间、最后一次写入数据的时间、最后一次检验磁盘（fask）的时间等文件系统相关的信息；<ul><li>-1个validbit数值，若该文件系统已被挂载，则valid bit为0，否则为1。</li></ul></li></ul><p>一般来说， superblock大小为1024Bytes，每个blockGroup都可能含有superblock， 主要作用是防止superblock挂掉。</p><h3 id="File-System-Description（文件系统描述说明）"><a href="#File-System-Description（文件系统描述说明）" class="headerlink" title="File System Description（文件系统描述说明）"></a>File System Description（文件系统描述说明）</h3><p>主要描述各个blockGroup的起止block号码。</p><h3 id="bitemap（对照表）"><a href="#bitemap（对照表）" class="headerlink" title="bitemap（对照表）"></a>bitemap（对照表）</h3><p>包括block bitemap及inode bitemap：<br>block bitemap：空或非空；<br>inode bitemap：未使用或正在使用。</p><p>以上所有信息，均可通过<strong> dumpe2fs </strong>这个命令来查询：</p><ul><li>dumpe2fs [-bh] 设备文件名<ul><li>-b：列出保留为坏道的部分；</li><li>-h：仅列出superblock的数据，不列出其他区段内容。</li></ul></li><li>df 调出目前挂载的设备</li></ul><p><strong> 命令行： </strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dumpe2fs –h /dev/sda2</span><br></pre></td></tr></table></figure><p><strong> 返回结果：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">dumpe2fs 1.42.9 (28-Dec-2013)</span><br><span class="line">Filesystem volume name:   &lt;none&gt;</span><br><span class="line">Last mounted on:          /</span><br><span class="line">Filesystem UUID:          c08f8c76-c1ea-48fd-8423-a33d6145a329</span><br><span class="line">Filesystem magic number:  0xEF53</span><br><span class="line">Filesystem revision #:    1 (dynamic)</span><br><span class="line">Filesystem features:      has_journal ext_attr resize_inode dir_index filetype needs_recovery extent 64bit flex_bg sparse_super large_file huge_file uninit_bg dir_nlink extra_isize</span><br><span class="line">Filesystem flags:         signed_directory_hash </span><br><span class="line">Default mount options:    user_xattr acl</span><br><span class="line">Filesystem state:         clean     # 文件系统没有问题（clean）</span><br><span class="line">Errors behavior:          Continue</span><br><span class="line">Filesystem OS type:       Linux</span><br><span class="line">Inode count:              1910080  # inode总数</span><br><span class="line">Block count:              7679488  #block总数</span><br><span class="line">Reserved block count:     383973</span><br><span class="line">Free blocks:              3575247   #还有多少block可用</span><br><span class="line">Free inodes:              1705442   #还有多少inode可用</span><br><span class="line">First block:              0</span><br><span class="line">Block size:               4096       #block大小</span><br><span class="line">Fragment size:            4096</span><br><span class="line">Group descriptor size:    64</span><br><span class="line">Reserved GDT blocks:      1022</span><br><span class="line">Blocks per group:         32768</span><br><span class="line">Fragments per group:      32768</span><br><span class="line">Inodes per group:         8128</span><br><span class="line">Inode blocks per group:   508</span><br><span class="line">Flex block group size:    16</span><br><span class="line">Filesystem created:       Thu Oct 19 04:42:40 2017</span><br><span class="line">Last mount time:          Sun Nov  5 18:34:03 2017</span><br><span class="line">Last write time:          Sun Nov  5 18:33:56 2017</span><br><span class="line">Mount count:              9</span><br><span class="line">Maximum mount count:      -1</span><br><span class="line">Last checked:             Mon Oct 30 02:06:59 2017</span><br><span class="line">Check interval:           0 (&lt;none&gt;)</span><br><span class="line">Lifetime writes:          7521 MB</span><br><span class="line">Reserved blocks uid:      0 (user root)</span><br><span class="line">Reserved blocks gid:      0 (group root)</span><br><span class="line">First inode:              11</span><br><span class="line">Inode size:               256</span><br><span class="line">Required extra isize:     28</span><br><span class="line">Desired extra isize:      28</span><br><span class="line">Journal inode:            8</span><br><span class="line">First orphan inode:       551269</span><br><span class="line">Default directory hash:   half_md4</span><br><span class="line">Directory Hash Seed:      967fd3cc-7cec-4848-a2e0-d40a6742de14</span><br><span class="line">Journal backup:           inode blocks</span><br><span class="line">Journal features:         journal_incompat_revoke journal_64bit</span><br><span class="line">Journal size:             128M  # 日志文件容量</span><br><span class="line">Journal length:           32768</span><br><span class="line">Journal sequence:         0x00010919</span><br><span class="line">Journal start:            1</span><br></pre></td></tr></table></figure><p><strong> 与目录树的关系 </strong></p><p>查看文件所占用的inode号码时，可以用ls –i命令处理。</p><h3 id="Ext2-Ext3文件的访问与日志文件系统的功能"><a href="#Ext2-Ext3文件的访问与日志文件系统的功能" class="headerlink" title="Ext2/Ext3文件的访问与日志文件系统的功能"></a>Ext2/Ext3文件的访问与日志文件系统的功能</h3><p>新增文件时，文件系统的行为为：</p><ul><li>先确定用户对于欲添加文件的目录是否有w与x的权限，若有的话才能添加；</li><li>根据inode bitemap找到没有使用的inode号码，并将新文件的权限/属性写入；</li><li>根据block bitemap找到没有使用中的block号码，并将实际的数据写入到block中，且更新inode的block指向数据;</li><li>将刚才写入的inode与block数据同步到inode bitemap与block bitemap，并更新superblock的内容。</li></ul><p>inode bitemap、block bitemap及superblock的数据经常变动，因此称之为<strong>中间数据（meta data）</strong>，当系统因不明原因中断时，可能造成中间数据的内容与实际数据的存放区域出现不一致的情况。</p><p>如果发生上述问题，系统会在重新启动的时候，通过Superblock中的valid bit（是否有挂载）及文件系统的state（clean与否）等状态来判断是否强制进行数据一致性的检查。若有需要检查时，则以e2fsck这支程序进行。</p><p>因为检查需要扫描整个文件系统，故非常耗时，<strong>日志文件系统</strong>应运而生。</p><p>其工作模式如下：</p><ul><li>预备：当系统写入一个文件时，会先在日志记录块中记录某个文件准备写入的信息；</li><li>实际写入：开始写入文件的权限与数据，开始更新meta data的数据；</li><li>结束：完成数据与meta data的更新后，在日志记录块中完成该文件的记录。</li></ul><p>只要只需扫描问题文件即可，可以快速定位，进而达到快速修复文件系统的目的。</p><p><strong> 而Ext3与Ext2的区别就在于引入了日志文件系统的功能。</strong></p><h3 id="Linux文件系统的操作"><a href="#Linux文件系统的操作" class="headerlink" title="Linux文件系统的操作"></a>Linux文件系统的操作</h3><p>加载到内存中的文件，如果频繁的写入到硬盘中，效率会非常低，故引入异步处理（asynchronously）的方式。</p><p>其运行模式为，若内存中的数据发生更改，此时修改部分数据会被设置为dirty，系统不定时的将dirty的数据写回磁盘，以保持内存数据与硬盘数据的一致性。</p><p>可使用<strong>sync</strong>命令 来强制将内存中的dirty数据写回到磁盘中去。</p><hr><h2 id="文件系统的简单操作"><a href="#文件系统的简单操作" class="headerlink" title="文件系统的简单操作"></a>文件系统的简单操作</h2><h3 id="磁盘与目录的容量：df，du"><a href="#磁盘与目录的容量：df，du" class="headerlink" title="磁盘与目录的容量：df，du"></a>磁盘与目录的容量：df，du</h3><blockquote><p>df：列出文件系统的整体磁盘使用量</p></blockquote><ul><li>-h：以人们较易阅读的GB/MB/KB等格式自行显示；</li><li>-i：以inode的数量来显示。</li></ul><blockquote><p>du：评估文件系统的磁盘使用量</p></blockquote><ul><li>-h：以人们较易阅读的GB/MB/KB等格式自行显示；</li><li>-s：列出总量而已。</li></ul><h3 id="连接文件：ln"><a href="#连接文件：ln" class="headerlink" title="连接文件：ln"></a>连接文件：ln</h3><blockquote><p>hard link（硬连接或实际连接）</p></blockquote><ul><li><p>hard link只是在某个目录下新建一条文件名连接到某inode号码的关联记录而已；</p></li><li><p>如果你将任何一个文件名删除，其实inode与block还是存在的；</p></li><li><p>通常情况下，不占用inode与block，只是在目录的block中添加一条记录而已。</p></li><li><p>Hard link的限制为：</p><ul><li>不能跨文件系统；</li><li>不能连接到目录。</li></ul></li></ul><blockquote><p>symbolic link（符号连接，即快捷方式）</p></blockquote><p>symbolic link实际上是创建一个独立的文件指向某个文件的文件名，会占用inode与block。</p><ul><li>ln [-sf]<ul><li>-s：默认硬连接，添加s为符号连接；</li><li>-f：如果目标文件存在时，直接删除后再创建。</li></ul></li></ul><h3 id="目录的连接数量"><a href="#目录的连接数量" class="headerlink" title="目录的连接数量"></a>目录的连接数量</h3><p>新建目录连接数为2，且上一级目录增加1，因为创建目录时会出现3个东西：</p><p><strong>filename</strong></p><p><strong>filename/. 当前目录</strong></p><p><strong>filename/.. 上一级目录</strong></p><p>前两个等同，第三个为上一级目录。</p><hr><h2 id="磁盘的分区、格式化、检验与挂载"><a href="#磁盘的分区、格式化、检验与挂载" class="headerlink" title="磁盘的分区、格式化、检验与挂载"></a>磁盘的分区、格式化、检验与挂载</h2><h3 id="磁盘分区：fdisk"><a href="#磁盘分区：fdisk" class="headerlink" title="磁盘分区：fdisk"></a>磁盘分区：fdisk</h3><blockquote><p>fdisk /dev/hdc</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Welcome to fdisk (util-linux 2.23.2).</span><br><span class="line">Changes will remain in memory only, until you decide to write them.</span><br><span class="line">Be careful before using the write command.</span><br><span class="line">Command (m for help): m</span><br><span class="line">Command action</span><br><span class="line">   a   toggle a bootable flag</span><br><span class="line">   b   edit bsd disklabel</span><br><span class="line">   c   toggle the dos compatibility flag</span><br><span class="line">   d   delete a partition  # 删除1个分区 </span><br><span class="line">   g   create a new empty GPT partition table</span><br><span class="line">   G   create an IRIX (SGI) partition table</span><br><span class="line">   l   list known partition types</span><br><span class="line">   m   print this menu</span><br><span class="line">   n   add a new partition  # 新增一个分区</span><br><span class="line">   o   create a new empty DOS partition table</span><br><span class="line">   p   print the partition table  # 打印分区表</span><br><span class="line">   q   quit without saving changes  # 不存储退出</span><br><span class="line">   s   create a new empty Sun disklabel</span><br><span class="line">   t   change a partition&apos;s system id</span><br><span class="line">   u   change display/entry units</span><br><span class="line">   v   verify the partition table</span><br><span class="line">   w   write table to disk and exit  # 保存退出</span><br><span class="line">   x   extra functionality (experts only)</span><br></pre></td></tr></table></figure><blockquote><p>输入p打印分区表：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Command (m for help): p</span><br><span class="line">Disk /dev/sda: 42.9 GB, 42949672960 bytes, 83886080 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label type: dos</span><br><span class="line">Disk identifier: 0x000d5bbd</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1   *        2048      411647      204800   83  Linux</span><br><span class="line">/dev/sda2          411648    61847551    30717952   83  Linux</span><br><span class="line">/dev/sda3        61847552    83886079    11019264   83  Linux</span><br><span class="line"># 设备文件名 开机区否 开始柱面   结束柱面 1KB大小容量 磁盘分区内的系统</span><br></pre></td></tr></table></figure><blockquote><p>fdisk –l 查询所有分区情况</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Disk /dev/sda: 42.9 GB, 42949672960 bytes, 83886080 sectors</span><br><span class="line">Units = sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes # 扇区大小</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disk label type: dos</span><br><span class="line">Disk identifier: 0x000d5bbd</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/sda1   *        2048      411647      204800   83  Linux</span><br><span class="line">/dev/sda2          411648    61847551    30717952   83  Linux</span><br><span class="line">/dev/sda3        61847552    83886079    11019264   83  Linux</span><br></pre></td></tr></table></figure><p><strong>注意，只要最后不按w，之前的所有操作均无效，所以可以练习删除及新增分区。</strong></p><blockquote><p>新增分区需要注意的地方：</p></blockquote><ul><li>SATA硬盘最多支持到15号的分区，IDE最多支持到63号；</li><li>fdisk没有办法处理大于2TB以上的磁盘分区（2TB以上使用GNU的parted命令）。</li></ul><h3 id="磁盘格式化"><a href="#磁盘格式化" class="headerlink" title="磁盘格式化"></a>磁盘格式化</h3><blockquote><p>mkfs（make file system） [-t 文件系统格式] 设备文件名</p></blockquote><ul><li>-t：可以接文件系统格式，例如ext3，ext2，vfat等（系统有支持才会生效）。</li></ul><blockquote><p>mkefs</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mke2fs  [  -c  | -l filename ] [ -b block-size ] [ -D ] [ -f fragment-size ] [ -g blocks-per-group ] [ -G number-of-groups ] [ -i bytes-per-inode ] [ -I</span><br><span class="line">       inode-size ] [ -j ] [ -J journal-options ] [ -N number-of-inodes ] [ -n ] [ -m reserved-blocks-percentage ] [ -o creator-os ] [ -O feature[,...]  ] [ -q</span><br><span class="line">       ] [ -r fs-revision-level ] [ -E extended-options ] [ -v ] [ -F ] [ -L volume-label ] [ -M last-mounted-directory ] [ -S ] [ -t fs-type ] [ -T usage-type</span><br><span class="line">       ] [ -U UUID ] [ -V ] device [ blocks-count ]</span><br></pre></td></tr></table></figure><h3 id="磁盘检验：fsck，badblocks"><a href="#磁盘检验：fsck，badblocks" class="headerlink" title="磁盘检验：fsck，badblocks"></a>磁盘检验：fsck，badblocks</h3><p>fsck：File System Check</p><h3 id="磁盘挂载：mount"><a href="#磁盘挂载：mount" class="headerlink" title="磁盘挂载：mount"></a>磁盘挂载：mount</h3><h3 id="磁盘参数修改：mknod"><a href="#磁盘参数修改：mknod" class="headerlink" title="磁盘参数修改：mknod"></a>磁盘参数修改：mknod</h3><p>设备的文件有magor与minor数值：</p><p><strong> ll /dev/sda* </strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">brw-rw----. 1 root disk 8, 0 Nov  6 02:07 /dev/sda</span><br><span class="line">brw-rw----. 1 root disk 8, 1 Nov  6 02:07 /dev/sda1</span><br><span class="line">brw-rw----. 1 root disk 8, 2 Nov  6 02:07 /dev/sda2</span><br><span class="line">brw-rw----. 1 root disk 8, 3 Nov  6 02:07 /dev/sda3</span><br><span class="line"># 8：magor（主设备代码） 0-3：minor（次设备代码）</span><br></pre></td></tr></table></figure><hr><h2 id="设置开机挂载"><a href="#设置开机挂载" class="headerlink" title="设置开机挂载"></a>设置开机挂载</h2><h3 id="开机挂载"><a href="#开机挂载" class="headerlink" title="开机挂载"></a>开机挂载</h3><blockquote><p>cat /etc/fstab</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UUID=c08f8c76-c1ea-48fd-8423-a33d6145a329  /        ext4    defaults        1 1</span><br><span class="line">UUID=9b54bd04-5920-4bf5-b94b-1ab6a753c373  /boot   ext4    defaults        1 2</span><br><span class="line">UUID=5c47e29d-176f-464d-ba1f-e5fa98e9a02f  /home    ext4    defaults        1 2</span><br><span class="line">UUID=fbc385ee-49c6-45b0-bc2b-248a599f6f21  swap     swap    defaults        0 0</span><br></pre></td></tr></table></figure><p>UUID码全称是通用唯一识别码 (Universally Unique Identifier, UUID),它 是一个软件建构的标准，亦为自由软件基金会 (Open Software Foundation, OSF) 的组织在分布式计算环境 (Distributed Computing Environment, DCE) 领域的一部分。UUID 的目的，是让分布式系统中的所有元素，都能有唯一的辨识信息，而不需要通过中央控制端来做辨识信息的指定。</p><ul><li>第二列：挂载点；</li><li>第三列：磁盘分区的文件系统；</li><li>第四列：文件系统参数；</li><li>第五列：能否被dump备份命令作用。<ul><li>0：不要做dump备份；1：每天进行dump备份；2：其他不定日期dump备份</li></ul></li><li>第六列：是否以fsck检验扇区。<ul><li>开机的过程中，系统默认会以fsck检验我们的文件系统是否完整；</li><li>特殊文件系统不需要检验，如swap、/proc与/sys等；</li><li>0：不检验 1：优先检验 2：次要检验</li></ul></li></ul><p><strong> 注意：/etc/fstab为开机时的配置文件，实际文件系统的挂载是记录到etc/mtab与/proc/mounts这两个文件中去的。</strong></p><h3 id="特殊设备loop挂载"><a href="#特殊设备loop挂载" class="headerlink" title="特殊设备loop挂载"></a>特殊设备loop挂载</h3><hr><h2 id="内存交换空间（swap）的构建"><a href="#内存交换空间（swap）的构建" class="headerlink" title="内存交换空间（swap）的构建"></a>内存交换空间（swap）的构建</h2><h3 id="使用物理分区构建"><a href="#使用物理分区构建" class="headerlink" title="使用物理分区构建"></a>使用物理分区构建</h3><p>swap的功能就是在应付物理内存不足的情况下所造成的内存扩展记录的功能。</p><p>新建swap分区的方法：</p><ul><li>分区：先使用fdisk在你的磁盘中分出一个分区给系统作为swap；<ul><li>操作完之后，执行partprobe让内核更新分区表。</li></ul></li><li>格式化：mkswap 设备文件名；</li><li>使用：swap设备启动，swapon 设备文件名；</li><li>查看：通过free命令查看内存的使用情况。</li></ul><h3 id="swap使用上的限制"><a href="#swap使用上的限制" class="headerlink" title="swap使用上的限制"></a>swap使用上的限制</h3><ul><li>单一swap已经没有2GB的限制；</li><li>最多仅能创建32个swap；</li><li>swap总量最大仅能达64GB。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为Linux系列教程的第1篇，主要讲解主机规划和磁盘分区，参考书籍为&lt;a href=&quot;http://linux.vbird.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;鸟哥的Linux私房菜&lt;/a&gt;。&lt;/p&gt;
&lt;/
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux教程3--文件与目录管理</title>
    <link href="http://yoursite.com/Linux%E6%95%99%E7%A8%8B3--%E6%96%87%E4%BB%B6%E4%B8%8E%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/Linux教程3--文件与目录管理/</id>
    <published>2018-03-18T14:00:16.000Z</published>
    <updated>2018-04-05T14:28:40.816Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为Linux系列教程的第1篇，主要讲解主机规划和磁盘分区，参考书籍为<a href="http://linux.vbird.org/" target="_blank" rel="noopener">鸟哥的Linux私房菜</a>。</p></blockquote><h2 id="目录的相关操作"><a href="#目录的相关操作" class="headerlink" title="目录的相关操作"></a>目录的相关操作</h2><h3 id="比较特殊的目录"><a href="#比较特殊的目录" class="headerlink" title="比较特殊的目录"></a>比较特殊的目录</h3><ul><li>.：代表当前的目录，也可以用./来表示；</li><li>..：代表上一层目录，也可以用../来表示；</li><li>~:代表当前用户的主目录；</li><li>-：代表前一个工作目录；</li><li>~account：代表account这个用户的主目录。</li></ul><h3 id="常见的处理目录的命令"><a href="#常见的处理目录的命令" class="headerlink" title="常见的处理目录的命令"></a>常见的处理目录的命令</h3><ul><li>cd（change directory）：切换目录；</li><li>pwd（print working directory）：显示当前目录；</li><li>mkdir（make directory）：新建一个新的目录；</li></ul><blockquote><p>默认情况下，所需要的目录得一层一层创建才可以，如果想直接创建，可以添加-p参数。</p></blockquote><ul><li>rmdir（remove directory）：删除一个空的目录。</li></ul><blockquote><p>默认情况下，所需要的目录得一层一层删除才可以，如果想直接删除，可以添加-r参数。</p></blockquote><hr><h2 id="文件与目录管理"><a href="#文件与目录管理" class="headerlink" title="文件与目录管理"></a>文件与目录管理</h2><h3 id="查看文件和目录"><a href="#查看文件和目录" class="headerlink" title="查看文件和目录"></a>查看文件和目录</h3><ul><li>ls:<ul><li>-a：全部的文件；</li><li>-d：仅列出文件本身；</li><li>-l：列出长数据串。</li></ul></li></ul><blockquote><p>注意：ll为ls –l的简写。</p></blockquote><h3 id="复制、删除与移动"><a href="#复制、删除与移动" class="headerlink" title="复制、删除与移动"></a>复制、删除与移动</h3><ul><li><p>cp（copy，复制文件或目录）</p><ul><li>-a：相当于-pdr的意思；</li><li>-i：若目标文件（destination）已经存在时，在覆盖时会先询问操作的进行；</li><li>-r：目录递归持续复制。</li></ul></li><li><p>rm（remove，删除文件或目录）</p><ul><li>-f：force的意思，忽略不存在的文件；</li><li>-i：互动模式，删除前会询问用户是否操作；</li><li>-r：目录递归持续删除。</li></ul></li><li><p>mv（move，移动文件或目录）</p><ul><li>-f：force的意思，如果目标文件已存在，强制覆盖；</li><li>-i：互动模式；</li><li>-u：若目标文件已经存在，且source比较新，才会更新（update）。</li></ul></li></ul><hr><h2 id="文件内容查阅"><a href="#文件内容查阅" class="headerlink" title="文件内容查阅"></a>文件内容查阅</h2><h3 id="文件内容查看"><a href="#文件内容查看" class="headerlink" title="文件内容查看"></a>文件内容查看</h3><blockquote><p>cat（concatenate）：由第一行开始显示文件内容；</p></blockquote><ul><li>-n：打印出行号</li></ul><blockquote><p>tac（反向列示）；</p></blockquote><blockquote><p>nl（添加行号打印）；</p></blockquote><ul><li><p>-b：指定行号指定的方式：</p><ul><li>-b a：表示不论是否为空行，也同样列出行号（类似于cat -n）；</li><li>-b t：如果有空行，空行不列出行号（默认值）。</li></ul></li><li><p>-n：列出行号表示的方法:</p><ul><li>-n ln：行号在最左方显示；</li><li>-n rn：行号在最右方显示，且不加零；</li><li>-n rz：行号在最右方显示，且加零。</li></ul></li><li><p>-w：行号字段占用的位数。</p></li></ul><blockquote><p>可翻页查看（more和less）；</p></blockquote><blockquote><p>数据选取（head/tail [-n number] 文件）；</p></blockquote><blockquote><p>od（非纯文本文件）</p></blockquote><h3 id="文件时间属性"><a href="#文件时间属性" class="headerlink" title="文件时间属性"></a>文件时间属性</h3><ul><li>modification time（mtime） 内容被修改时，更新；</li><li>status time（ctime） 权限和属性被修改时，更新；</li><li>access time（atime） 被取用时，更新。</li></ul><h3 id="touch命令"><a href="#touch命令" class="headerlink" title="touch命令"></a>touch命令</h3><ul><li>创建一个空的文件；</li><li>将某个文件的日期修改为当前日期（mtime和atime）。</li></ul><hr><h2 id="文件默认权限（umask）"><a href="#文件默认权限（umask）" class="headerlink" title="文件默认权限（umask）"></a>文件默认权限（umask）</h2><p>Umask就是指定当前用户在新建文件或目录时候的权限默认值，获取方式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">umask    return 0022</span><br><span class="line">umask –S  return u=rwx, g=rx, o=rx</span><br></pre></td></tr></table></figure><p><strong> 数字代表缺失的权限。</strong></p><p>root的umask默认为022，这是基于安全的考虑，至于一般身份用户，通常他们的umask为002，即保留同用户组的写入权利。</p><p><strong> 查看文件类型：file </strong></p><hr><h2 id="命令与文件的查询"><a href="#命令与文件的查询" class="headerlink" title="命令与文件的查询"></a>命令与文件的查询</h2><h3 id="脚本文件名的查询"><a href="#脚本文件名的查询" class="headerlink" title="脚本文件名的查询"></a>脚本文件名的查询</h3><p><strong> which: </strong></p><ul><li>-a：将所有由PATH目录中可以找到的命令均列出，而不只是第一个被找到的命令名称。</li></ul><p><strong> 文件名的查找 </strong></p><blockquote><p>find低效（查找硬盘），通常采用whereis或者locate，这两个均采用数据库来查找，所以较为快速。</p></blockquote><ul><li><p>whereis</p><ol><li>-b：只找二进制文件；</li><li>-m：只找说明文件manual下的文件；</li><li>-s：只找source源文件；</li><li>-u：查找不在上述三个选项当中的其他特殊文件。</li></ol></li><li><p>locate</p><ol><li>-i：忽略大小写的差异；</li><li>-r：后面可接正则表达式的显示方式。</li><li>locate是根据已创建的数据库/var/lib/mlocate/里面的数据所查找到的，该库默认一天更新一次，所以会有延时；</li><li>强制更新数据库的命令为updatedb，该命令根据/etc/updated.conf的设置去寻找系统硬盘内的文件名，并更新var/lib/mlocate/内的数据库文件。</li></ol></li><li><p>find</p></li></ul><blockquote><p>与时间有关的参数（mtime/ctime/atime）</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-mtime n：n天之前的一天之内被更改过的文件；</span><br><span class="line">-mtime +n：n天之前（不含n天本身）被更改过的文件；</span><br><span class="line">-mtime -n：n天之内（含n天本身）被更改过的文件；</span><br><span class="line">-newer file：列出比file更新的文件名。</span><br></pre></td></tr></table></figure><blockquote><p>与用户或用户组名有关的参数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-uid：用户ID；</span><br><span class="line">-gid：用户组ID；</span><br><span class="line">-user name：name为用户名称；</span><br><span class="line">-group name：name为用户组名称；</span><br><span class="line">-nouser</span><br><span class="line">-nogroup</span><br></pre></td></tr></table></figure><blockquote><p>与文件权限及名称相关的参数</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-name filename：查找文件名为filename的文件；</span><br><span class="line">-size [+-] SIZE：查找比SIZE还要大（+）或小（-）的文件，SIZE的规格有：</span><br><span class="line">c：Bytes，k：1024 Bytes；</span><br><span class="line">-type TYPE：TYPE的类型有：一般正规文件（f）、设备文件（b/c）、目录（d）、连接文件（l）、socket（s）、FIFO（p）等属性；</span><br><span class="line">-perm mode：文件权限刚好等于mode的文件；</span><br><span class="line">-perm -mode：文件权限大于等于mode的文件；</span><br><span class="line">-perm +mode：文件权限小于等于mode（子集）的文件；</span><br></pre></td></tr></table></figure><blockquote><p>其他可进行的操作</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-exec command：command为其他命令；</span><br><span class="line">-print：将结果打印到屏幕上，默认操作。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为Linux系列教程的第1篇，主要讲解主机规划和磁盘分区，参考书籍为&lt;a href=&quot;http://linux.vbird.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;鸟哥的Linux私房菜&lt;/a&gt;。&lt;/p&gt;
&lt;/
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Hadoop系列教程1--概述</title>
    <link href="http://yoursite.com/Hadoop%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B1--%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/Hadoop系列教程1--概述/</id>
    <published>2018-03-16T14:00:16.000Z</published>
    <updated>2018-04-05T12:17:42.185Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为Hadoop系列教程的第1篇，主要介绍Hadoop的产生背景及其架构等。</p></blockquote><h2 id="Hadoop产生背景"><a href="#Hadoop产生背景" class="headerlink" title="Hadoop产生背景"></a>Hadoop产生背景</h2><ul><li><p>Hadoop最早起源于Nutch，Nutch的目标是设计构建一个大型的全网搜索引擎，包括网页抓取、索引、查询等功能，但随着抓取网页数量的增加，遇到了严重的可扩展性问题——如何解决数十亿网页的存储和索引问题。</p></li><li><p>2003年、2004年、2005年年谷歌发表的两篇论文为该问题提供了可行性方案：</p><ul><li>03分布式文件系统（GFS），可用于处理海量网页的存储；</li><li>04分布式计算框架MapReduce，可用于处理海量网页的索引计算；</li><li>05BigTable—被Hadoop借鉴，即Hbase（非关系型数据库）。</li></ul></li><li>Nutch的开发人员完成了相应的开源实现HDFS和MapReduce，并从Nutch中剥离出来成为独立项目Hadoop，到2008年1月，Hadoop成为Apache顶级项目，迎来了它的快速发展期。</li></ul><hr><h2 id="什么是Hadoop？"><a href="#什么是Hadoop？" class="headerlink" title="什么是Hadoop？"></a>什么是Hadoop？</h2><ol><li>Hadoop是Apache（archive.apache.org/dist/）旗下的一套开源软件；</li><li>Hadoop提供的功能：利用服务器集群对数据进行存储，根据用户的自定义业务逻辑，对海量数据进行分布式计算；</li><li>广义上来讲，Hadoop通常是指一个更广泛的概念—Hadoop生态圈。</li></ol><p>下图为Hadoop生态圈示意图：</p><p><img src="http://p3f66obex.bkt.clouddn.com/8-hadoopshengtai.png" alt=""></p><h3 id="重点组件："><a href="#重点组件：" class="headerlink" title="重点组件："></a>重点组件：</h3><blockquote><p>名字来源：作者女儿的玩具名为Hadoop</p></blockquote><ul><li>HDFS：分布式文件系统；</li><li>MapReduce：分布式运算程序开发框架；</li><li>Sqoop：关系型数据库与HDFS数据相互迁移工具；</li><li>Flume：日志数据采集框架；</li><li>Zookeeper：分布式协调服务基础组件；</li><li>Hive：SQL数据仓库工具，支持SQL语言的框架（将SQL语句翻译成底层的MapReduce指令）；</li><li>Pig：高级的API，支持SQL语言的框架（将SQL语句翻译成底层的MapReduce指令）；</li><li>Mahout：机器学习框架；</li><li>YARN：资源调度系统；</li><li>Hbase：基于Hadoop分布式海量数据库。</li></ul><hr><h2 id="Hadoop解决了什么问题？"><a href="#Hadoop解决了什么问题？" class="headerlink" title="Hadoop解决了什么问题？"></a>Hadoop解决了什么问题？</h2><ul><li style="list-style: none"><input type="checkbox" checked="checked"> 海量数据的存储（HDFS）；</li><li style="list-style: none"><input type="checkbox" checked="checked"> 海量数据的技术（MapReduce）；</li><li style="list-style: none"><input type="checkbox" checked="checked"> 资源调度（YARN）。</li></ul><hr><h2 id="分布式架构问题"><a href="#分布式架构问题" class="headerlink" title="分布式架构问题"></a>分布式架构问题</h2><h3 id="单机的问题"><a href="#单机的问题" class="headerlink" title="单机的问题"></a>单机的问题</h3><ul><li>存储的能力有限；</li><li>计算能力有限；</li><li>有单点故障；</li><li>……</li></ul><h3 id="分布式架构解决了单机的问题"><a href="#分布式架构解决了单机的问题" class="headerlink" title="分布式架构解决了单机的问题"></a>分布式架构解决了单机的问题</h3><h3 id="经典分布式主从架构（Master-Slave）"><a href="#经典分布式主从架构（Master-Slave）" class="headerlink" title="经典分布式主从架构（Master-Slave）"></a>经典分布式主从架构（Master-Slave）</h3><p><img src="http://p3f66obex.bkt.clouddn.com/8-master-slave.jpg" alt=""></p><blockquote><p>Master负责管理（相当于老大），Master可以有多个，防止单点故障的发生，多个老大选举（Zookeeper框架负责）；</p></blockquote><blockquote><p>Slave负责干活（相当于小弟），Salve有多个，并且可以动态的添加或移除；</p></blockquote><blockquote><p>优先使用Linux系统（主要开源免费，节省成本）。</p></blockquote><hr><h2 id="Hadoop架构"><a href="#Hadoop架构" class="headerlink" title="Hadoop架构"></a>Hadoop架构</h2><p><img src="http://p3f66obex.bkt.clouddn.com/8-hadoopjiagou.jpg" alt=""></p><h3 id="Hadoop2-0："><a href="#Hadoop2-0：" class="headerlink" title="Hadoop2.0："></a>Hadoop2.0：</h3><ul><li>HDFS：<ul><li>Master：NameNode（老大）；</li><li>Salve：DataNode（小弟）。</li></ul></li><li>YARN：<ul><li>Master：ResourceManager（老大）；</li><li>Slave：NodeManager（小组长）。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为Hadoop系列教程的第1篇，主要介绍Hadoop的产生背景及其架构等。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;Hadoop产生背景&quot;&gt;&lt;a href=&quot;#Hadoop产生背景&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="Hadoop" scheme="http://yoursite.com/categories/Hadoop/"/>
    
    
      <category term="大数据" scheme="http://yoursite.com/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="Hadoop" scheme="http://yoursite.com/tags/Hadoop/"/>
    
  </entry>
  
  <entry>
    <title>Linux教程2--文件权限与目录设置</title>
    <link href="http://yoursite.com/Linux%E6%95%99%E7%A8%8B2--%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%9B%AE%E5%BD%95%E8%AE%BE%E7%BD%AE/"/>
    <id>http://yoursite.com/Linux教程2--文件权限与目录设置/</id>
    <published>2018-03-15T14:00:16.000Z</published>
    <updated>2018-04-05T14:28:20.740Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为Linux系列教程的第1篇，主要讲解主机规划和磁盘分区，参考书籍为<a href="http://linux.vbird.org/" target="_blank" rel="noopener">鸟哥的Linux私房菜</a>。</p></blockquote><h2 id="Linux文件权限"><a href="#Linux文件权限" class="headerlink" title="Linux文件权限"></a>Linux文件权限</h2><p>通过命令’ls -al’可以查看当前目录下的文件权限，如下图所示：</p><p><img src="http://p3f66obex.bkt.clouddn.com/7-%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90.png" alt=""></p><p>第一列代表这个文件的类型和权限：</p><p><strong> 第一个字符代表这个文件是“目录、文件或者链接文件等” </strong></p><ul><li>[d]：目录</li><li>[-]：文件</li><li>[l]：连接文件（linkfile）</li><li>[b]：设备中可供存储的接口设备</li><li>[c]：设备中的串行接口设备，例如键盘、鼠标等</li></ul><p>接下来的字符，以3个为1组，且均为rwx3个参数的组合，[r]代表可读（read），[w]代表可写（write），[x]代表可执行（execute）。要注意的是，这三个权限的位置不会改变，如果没有权限，就会出现[-]而已。<br>依次为用户权限、同用户组权限、其他用户权限。</p><p><strong> 第二列代表有多少个文件名连接到此节点（i-node） </strong><br><strong> 第三列代表这个文件（或目录）的所有者账号 </strong><br><strong> 第四列代表这个文件（或目录）的所属用户组 </strong><br><strong> 第五列为文件大小，默认单位为B </strong><br><strong> 第六列为创建日期或最近修改日期 </strong><br><strong> 第七列为文件名 </strong></p><hr><h2 id="改变文件属性和权限"><a href="#改变文件属性和权限" class="headerlink" title="改变文件属性和权限"></a>改变文件属性和权限</h2><blockquote><p>chgrp：改变文件所属用户组；</p></blockquote><p>要被改变的用户组名必须在/etc/group文件内存在才可以。</p><blockquote><p>chown：改变文件所属用户；</p></blockquote><p>要被改变的用户名必须在/etc/group文件内存在才可以。</p><blockquote><p>chmod：改变文件的权限。</p></blockquote><ul><li>可以使用数字来代表权限：<ul><li>[r]：4</li><li>[w]：2</li><li>[ x ]：1</li></ul></li></ul><p>3个权限的分数需要累加；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 filename</span><br></pre></td></tr></table></figure><ul><li>符号类型改变文件权限：</li></ul><table><thead><tr><th style="text-align:center">命令头部</th><th style="text-align:center">用户</th><th style="text-align:center">操作</th><th style="text-align:center">权限</th></tr></thead><tbody><tr><td style="text-align:center">chmod</td><td style="text-align:center">u（user） <br> g（group） <br> o（others）<br> a（all）</td><td style="text-align:center">+（加入）<br> -（除去）<br> =（设置）</td><td style="text-align:center">r <br> w <br> x</td></tr></tbody></table><hr><h2 id="目录与文件的权限含义"><a href="#目录与文件的权限含义" class="headerlink" title="目录与文件的权限含义"></a>目录与文件的权限含义</h2><h3 id="权限对文件的重要性"><a href="#权限对文件的重要性" class="headerlink" title="权限对文件的重要性"></a>权限对文件的重要性</h3><ul><li>[r]：可读取此文件的实际内容；</li><li>[w]：可以编辑、新增、修改该文件的内容（但不包括删除该文件）；</li><li>[ x ]：此文件具有可被系统执行的权限。</li></ul><h3 id="权限对目录的重要性"><a href="#权限对目录的重要性" class="headerlink" title="权限对目录的重要性"></a>权限对目录的重要性</h3><ul><li>[r]：具有读取目录结构列表的权限；</li><li>[w]： 具有更改该目录结构列表的权限；<ul><li>新建新的文件和目录；</li><li>删除已经存在的文件和目录（不论该文件的权限为何）；</li><li>将已存在的文件和目录进行重命名；</li><li>转移该目录内的文件、目录位置。</li></ul></li><li style="list-style: none"><input type="checkbox" checked="checked"> ：用户能否进入该目录成为工作目录（working directory）。</li></ul><blockquote><p>需要注意的是，要开放目录给任何人浏览时，应该至少给予 [r]和[x] 的权限，仅仅给[r]的权限，则只能获取该目录下的文件列表，获取不到具体的文件。</p></blockquote><hr><h2 id="Linux文件种类和扩展名"><a href="#Linux文件种类和扩展名" class="headerlink" title="Linux文件种类和扩展名"></a>Linux文件种类和扩展名</h2><h3 id="文件种类"><a href="#文件种类" class="headerlink" title="文件种类"></a>文件种类</h3><ul><li>第一个属性为[-]，主要包括普通文件（regular file）、纯文本文件（ASCII）、二进制文件（binary）、数据格式文件（data）。</li><li>第一个属性为[d]，代表目录（directory）。</li><li>第一个属性为[l]，代表连接文件（link file）。</li><li>设备与设备文件（device）,与设备外设和存储等相关的一些文件，通常均集中在/dev目录下，通常可分为两种:<ul><li>块（block）设备文件，就是一些存储数据，以提供系统随机访问的接口设备，例如硬盘、软盘等，第一个属性为[b]；</li><li>字符（character）设备文件，即是一些串行端口的接口设备，例如键盘、鼠标等。这些设备的特征是“一次性截取”，不能够截断输出，第一个属性为[c]。</li></ul></li><li>套接字（sockets）：<br>通常被用于网络上的数据连接，其第一个属性为[s]。</li><li>管道（FIFO，pipe）<br>类似于Windows下的快捷方式，主要目的在解决多个程序同时访问一个文件所造成的错误问题。FIFO是first-in-first-out的缩写，第一个属性为[p]。</li></ul><h3 id="Linux文件扩展名"><a href="#Linux文件扩展名" class="headerlink" title="Linux文件扩展名"></a>Linux文件扩展名</h3><p>一个Linux文件能不能被执行，与它的第一列的10个属性有关，与文件名没有关系，只要你的权限中有[x]的话，代表这个文件可被执行。<br>可执行不代表能够执行成功，能否执行成功取决于文件的内容。<br>常见的文件扩展名：</p><ul><li>*.sh：脚本或批处理文件；</li><li><em>.Z、</em>.tar、<em>.tar.gz、</em>.zip、*.tgz：经过打包的压缩文件；</li><li><em>.html、</em>.php：网页相关文件。</li></ul><h3 id="Linux文件名长度限制"><a href="#Linux文件名长度限制" class="headerlink" title="Linux文件名长度限制"></a>Linux文件名长度限制</h3><p>采用Ext2/Ext3文件系统时，针对文件的文件名长度限制为：</p><ul><li>单一文件和目录的最大容许文件名为255个字符；</li><li>包含完整路径名称及目录（/）的完整文件名为4096个字符。</li></ul><hr><h2 id="Linux目录配置"><a href="#Linux目录配置" class="headerlink" title="Linux目录配置"></a>Linux目录配置</h2><h3 id="Linux目录配置标准（FHS）"><a href="#Linux目录配置标准（FHS）" class="headerlink" title="Linux目录配置标准（FHS）"></a>Linux目录配置标准（FHS）</h3><p>FHS（Filesystem Hierarchy Standard）：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">可分享的（shareable）</th><th style="text-align:center">不可分享的（unshareable）</th></tr></thead><tbody><tr><td style="text-align:center">不变的（static）</td><td style="text-align:center">/usr（软件放置处） <br> /opt（第三方软件）</td><td style="text-align:center">/etc（配置文件） <br> /boot（开机与内核文件）</td></tr><tr><td style="text-align:center">可变动的（variable）</td><td style="text-align:center">/var/mail（用户邮件信箱）<br> /var/spool/news（新闻组）</td><td style="text-align:center">/var/run（程序相关） <br> /var/lock（程序相关）</td></tr></tbody></table><p>/（root）：根目录，与开机系统有关；<br>/usr（UNIX software resource）：与软件安装/执行相关；<br>/var（variable）：与系统运作过程有关。</p><h3 id="不可与根目录分开的目录："><a href="#不可与根目录分开的目录：" class="headerlink" title="不可与根目录分开的目录："></a>不可与根目录分开的目录：</h3><ul><li>/etc：配置文件；</li><li>/bin：重要执行文件；</li><li>/dev：所需要的设备文件；</li><li>/lib：执行文件所需的函数库与内核所需的模块；</li><li>/sbin：重要的系统执行文件。</li></ul><h3 id="目录树（directory-tree）"><a href="#目录树（directory-tree）" class="headerlink" title="目录树（directory tree）"></a>目录树（directory tree）</h3><ul><li>目录树的起始点为根目录（root，/）；</li><li>每一个目录不仅可以使用本地端的文件系统，也可以使用网络上的文件系统。举例来说，可以利用Network File System（NFS）服务器挂载特定目录；</li><li>每一个文件在此目录树中的文件名（包含完整路径）都是独一无二的。</li></ul><h3 id="绝对路径与相对路径"><a href="#绝对路径与相对路径" class="headerlink" title="绝对路径与相对路径"></a>绝对路径与相对路径</h3><ul><li>绝对路径：由根目录（/）开始写起的文件名或目录名称；</li><li>相对路径：相对于当前路径的文件名写法。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为Linux系列教程的第1篇，主要讲解主机规划和磁盘分区，参考书籍为&lt;a href=&quot;http://linux.vbird.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;鸟哥的Linux私房菜&lt;/a&gt;。&lt;/p&gt;
&lt;/
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux教程1--主机规划和磁盘分区</title>
    <link href="http://yoursite.com/Linux%E6%95%99%E7%A8%8B1--%E4%B8%BB%E6%9C%BA%E8%A7%84%E5%88%92%E5%92%8C%E7%A3%81%E7%9B%98%E5%88%86%E5%8C%BA/"/>
    <id>http://yoursite.com/Linux教程1--主机规划和磁盘分区/</id>
    <published>2018-03-13T14:00:16.000Z</published>
    <updated>2018-04-05T11:51:16.092Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文为Linux系列教程的第1篇，主要讲解主机规划和磁盘分区，参考书籍为<a href="http://linux.vbird.org/" target="_blank" rel="noopener">鸟哥的Linux私房菜</a>。</p></blockquote><h2 id="各硬件设备在Linux中的文件名"><a href="#各硬件设备在Linux中的文件名" class="headerlink" title="各硬件设备在Linux中的文件名"></a>各硬件设备在Linux中的文件名</h2><p>在Linux系统中，每个设备均被当做一个文件对待，几乎所有的硬件设备文件均在/dev这个目录内；</p><p>IDE接口的硬盘文件名为/dev/hd[a-d]；</p><p>SATA接口的硬盘文件名为/dev/sd[a-p]。</p><hr><h2 id="磁盘分区"><a href="#磁盘分区" class="headerlink" title="磁盘分区"></a>磁盘分区</h2><h3 id="磁盘连接的方式与设备文件名间的关系"><a href="#磁盘连接的方式与设备文件名间的关系" class="headerlink" title="磁盘连接的方式与设备文件名间的关系"></a>磁盘连接的方式与设备文件名间的关系</h3><blockquote><p>IDE接口：通常主机会有2个IDE接口，每个接口可以接2个设备，两接口通常被称为IDE1（primary）和IDE2（secondary），每个接口上的设备被区分为master设备和slave设备。</p></blockquote><table><thead><tr><th style="text-align:center">IDE</th><th style="text-align:center">master</th><th style="text-align:center">slave</th></tr></thead><tbody><tr><td style="text-align:center">IDE1（primary）</td><td style="text-align:center">/dev/hda</td><td style="text-align:center">/dev/hdb</td></tr><tr><td style="text-align:center">IDE2（secondary）</td><td style="text-align:center">/dev/hdc</td><td style="text-align:center">/dev/hdd</td></tr></tbody></table><blockquote><p>SATA接口：根据Linux内核检测到磁盘的顺序，跟接口编号没关系。</p></blockquote><h3 id="磁盘的组成复习"><a href="#磁盘的组成复习" class="headerlink" title="磁盘的组成复习"></a>磁盘的组成复习</h3><p>磁盘扇区每个为512Bytes，整块硬盘的第一个扇区特别重要，主要记录了2个重要信息：</p><ul><li><p>主引导分区（Master Boot Record, MBR），可以安装引导加载程序的地方，有446 Bytes；</p></li><li><p>分区表（partition table）：记录整块硬盘分区的状态，有64 Bytes。</p></li></ul><h3 id="磁盘分区表"><a href="#磁盘分区表" class="headerlink" title="磁盘分区表"></a>磁盘分区表</h3><p>由于分区表只有64 Bytes，最多容纳四个分区，这四个分区为主（Primary）或扩展（Extended）分区，分区的最小单位为柱面（cylinder）；<br>扩展分区继续切分出来的分区成为逻辑分区（logical partition）；<br>主分区和扩展分区最多只有4个（硬盘的限制）；<br>扩展分区最多只有一个（操作系统的限制）；<br>能被格式化作为数据访问的分区是主分区和逻辑分区，扩展分区无法被格式化。</p><h3 id="安装模式下，磁盘分区的选择"><a href="#安装模式下，磁盘分区的选择" class="headerlink" title="安装模式下，磁盘分区的选择"></a>安装模式下，磁盘分区的选择</h3><ul><li>目录树结构</li></ul><p>整个目录树结构最重要的是根目录（root directory），表示方法为/；<br>所有的文件均是由根目录衍生来的；<br>文件数据实际上存储在磁盘分区中，利用挂载的方式来结合目录树的架构与磁盘内的数据。</p><ul><li>文件系统与目录树之间的关系（挂载）</li></ul><p>所谓挂载就是利用一个目录作为进入点，将磁盘分区的数据放置在该目录下，也就是说，进入该目录就可以读取该分区。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文为Linux系列教程的第1篇，主要讲解主机规划和磁盘分区，参考书籍为&lt;a href=&quot;http://linux.vbird.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;鸟哥的Linux私房菜&lt;/a&gt;。&lt;/p&gt;
&lt;/
      
    
    </summary>
    
      <category term="Linux" scheme="http://yoursite.com/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Markdown基础语法</title>
    <link href="http://yoursite.com/Markdown%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/Markdown基础语法/</id>
    <published>2018-03-13T14:00:16.000Z</published>
    <updated>2018-04-05T11:45:29.655Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><strong>Markdown</strong>是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档。由于不同平台、网站Markdown引擎不完全相同，本文主要展示Hexo下的Markdown语法。</p></blockquote><hr><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><ul><li>#1级标题</li><li>##2级标题</li><li>…级标题</li></ul><blockquote><p>注意：几个#号则代表几级标题，最多6级。</p></blockquote><h2 id="段落缩进"><a href="#段落缩进" class="headerlink" title="段落缩进"></a>段落缩进</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">半方大的空白&amp;ensp;或&amp;#8194;看，飞碟</span><br><span class="line">全方大的空白&amp;emsp;或&amp;#8195;看，飞碟</span><br><span class="line">不断行的空白格&amp;nbsp;或&amp;#160;看，飞碟</span><br><span class="line">&amp;emsp;&amp;emsp;段落从此开始。</span><br></pre></td></tr></table></figure><p>半方大的空白&ensp;或&#8194;看，飞碟<br>全方大的空白&emsp;或&#8195;看，飞碟<br>不断行的空白格&nbsp;或&#160;看，飞碟<br>&emsp;&emsp;段落从此开始。</p><hr><h2 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h2><h3 id="字体、字号、颜色"><a href="#字体、字号、颜色" class="headerlink" title="字体、字号、颜色"></a>字体、字号、颜色</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;font face=&quot;黑体&quot;&gt;我是黑体字&lt;/font&gt;</span><br><span class="line">&lt;font face=&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;/font&gt;</span><br><span class="line">&lt;font face=&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;/font&gt;</span><br><span class="line">&lt;font color=#0099ff size=12 face=&quot;黑体&quot;&gt;黑体&lt;/font&gt;</span><br><span class="line">&lt;font color=#00ffff size=3&gt;null&lt;/font&gt;</span><br><span class="line">&lt;font color=gray size=5&gt;gray&lt;/font&gt;</span><br></pre></td></tr></table></figure><font face="黑体">我是黑体字</font><br><font face="微软雅黑">我是微软雅黑</font><br><font face="STCAIYUN">我是华文彩云</font><br><font color="#0099ff" size="12" face="黑体">黑体</font><br><font color="#00ffff" size="3">null</font><br><font color="gray" size="5">gray</font><h3 id="粗体、斜体、删除线"><a href="#粗体、斜体、删除线" class="headerlink" title="粗体、斜体、删除线"></a>粗体、斜体、删除线</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">**粗体**</span><br><span class="line">__粗体__</span><br><span class="line">*斜体*</span><br><span class="line">_斜体_</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p><strong>粗体</strong><br><strong>粗体</strong><br><em>斜体</em><br>_斜体_<br><del>删除线</del></p><hr><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><p>在三斜点之间添加代码即可。</p><blockquote><p>需要注意的是：上述的斜点并不是单引号，这个是初学者常犯的错误，它是键盘Tab键和Esc键之间的东东（就是带~标志的键）！</p></blockquote><p>指定代码形式，在后面追加形式说明即可，如：</p><p><img src="http://p3f66obex.bkt.clouddn.com/5-python.JPG" alt=""></p><p>显示为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import math</span><br><span class="line"></span><br><span class="line">def add_all(n):</span><br><span class="line">    total = n * (n + 1) / 2</span><br><span class="line">    return total</span><br></pre></td></tr></table></figure><hr><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>一个星号 / 一个加号 / 一个减号 +若干个空格 + 列表项内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 章节1</span><br><span class="line">- 章节2</span><br><span class="line">+ 章节3</span><br></pre></td></tr></table></figure><ul><li>章节1</li></ul><ul><li>章节2</li></ul><ul><li>章节3</li></ul><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>一个数字 + 一个英文句点 + 若干个空格 + 列表项内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 章节1</span><br><span class="line">2. 章节2</span><br><span class="line">3. 章节3</span><br></pre></td></tr></table></figure><ol><li>章节1</li><li>章节2</li><li>章节3</li></ol><h3 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- 嵌套列表1</span><br><span class="line"> + 嵌套列表2</span><br><span class="line"> + 嵌套列表3</span><br><span class="line">  - 嵌套列表4</span><br><span class="line">   * 嵌套列表5</span><br><span class="line">- 嵌套列表6</span><br></pre></td></tr></table></figure><ul><li>嵌套列表1<ul><li>嵌套列表2</li><li>嵌套列表3</li></ul><ul><li>嵌套列表4<ul><li>嵌套列表5</li></ul></li></ul></li><li>嵌套列表6</li></ul><hr><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><h3 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">| 项目        | 价格   |  数量  |</span><br><span class="line">| --------   | -----:  | :----:  |</span><br><span class="line">| 计算机     | \$1600 |   5     |</span><br><span class="line">| 手机        |   \$12   |   12   |</span><br><span class="line">| 管线        |    \$1    |  234  |</span><br></pre></td></tr></table></figure><blockquote><p>第2行通过左右的’:’设置表格的对齐形式，元素左边1个冒号为<strong>左对齐</strong>，右边1个为<strong>右对齐</strong>，两边均有为<strong>居中</strong>。</p></blockquote><h3 id="展现形式"><a href="#展现形式" class="headerlink" title="展现形式"></a>展现形式</h3><table><thead><tr><th>项目</th><th style="text-align:right">价格</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td>计算机</td><td style="text-align:right">\$1600</td><td style="text-align:center">5</td></tr><tr><td>手机</td><td style="text-align:right">\$12</td><td style="text-align:center">12</td></tr><tr><td>管线</td><td style="text-align:right">\$1</td><td style="text-align:center">234</td></tr></tbody></table><hr><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h3 id="索引链接"><a href="#索引链接" class="headerlink" title="索引链接"></a>索引链接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[阮树斌的个人博客](http://ruanshubin.top)</span><br></pre></td></tr></table></figure><p><a href="http://ruanshubin.top" target="_blank" rel="noopener">阮树斌的个人博客</a></p><h3 id="自动链接（尖括号）"><a href="#自动链接（尖括号）" class="headerlink" title="自动链接（尖括号）"></a>自动链接（尖括号）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;http://ruanshubin.top&gt;</span><br></pre></td></tr></table></figure><p><a href="http://ruanshubin.top" target="_blank" rel="noopener">http://ruanshubin.top</a></p><h3 id="图片链接"><a href="#图片链接" class="headerlink" title="图片链接"></a>图片链接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![GitHub Mark](http://github.global.ssl.fastly.net/images/modules/logos_page/GitHub-Mark.png &quot;GitHub Mark&quot;)</span><br></pre></td></tr></table></figure><blockquote><p>设置图片大小的话只能借助HTML标记。</p></blockquote><p><img src="http://github.global.ssl.fastly.net/images/modules/logos_page/GitHub-Mark.png" alt="GitHub Mark" title="GitHub Mark"></p><hr><blockquote><p>下面为流程图、序列图、甘特图的Mrakdown语法，需要注意的是Github上还未支持上述三种图的实现，我用<a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="noopener">Cmd Markdown</a>编辑阅读器来实现相关语法并截图展示。</p></blockquote><hr><h2 id="绘制流程图"><a href="#绘制流程图" class="headerlink" title="绘制流程图"></a>绘制流程图</h2><h3 id="定义元素的语法"><a href="#定义元素的语法" class="headerlink" title="定义元素的语法"></a>定义元素的语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tag=&gt;type:content:&gt;url</span><br></pre></td></tr></table></figure><ul><li>tag为元素名字</li><li>type是元素的类型，共六种</li></ul><ol><li>start # 开始</li><li>end # 结束</li><li>operation # 操作</li><li>subroutine # 子程序</li><li>input # 输入</li><li>ouput #输出</li></ol><ul><li>content为流程框中显示的内容，需要注意的是:与文本之间有空格</li><li>url为链接，与流程框中的内容绑定</li></ul><h3 id="流程图简单示范"><a href="#流程图简单示范" class="headerlink" title="流程图简单示范"></a>流程图简单示范</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flow</span><br><span class="line">st=&gt;start: 开始</span><br><span class="line">op=&gt;operation: 操作</span><br><span class="line">cond=&gt;condition: 是或否？</span><br><span class="line">e=&gt;end: 结束</span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br></pre></td></tr></table></figure><p>生成流程图如下：</p><p><img src="http://p3f66obex.bkt.clouddn.com/5-liuchengtu.JPG" alt=""></p><p>可以发现，生成流程图主要分为2步：</p><ul><li style="list-style: none"><input type="checkbox" checked="checked"> 定义元素</li><li style="list-style: none"><input type="checkbox" checked="checked"> 定义连接关系</li></ul><hr><h2 id="高效绘制序列图"><a href="#高效绘制序列图" class="headerlink" title="高效绘制序列图"></a>高效绘制序列图</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">```seq</span><br><span class="line">Alice-&gt;Bob: Hello Bob, how are you?</span><br><span class="line">Note right of Bob: Bob thinks</span><br><span class="line">Bob--&gt;Alice: I am good thanks!</span><br></pre></td></tr></table></figure><p><img src="http://p3f66obex.bkt.clouddn.com/5-xulietu.JPG" alt=""></p><hr><h2 id="高效绘制甘特图"><a href="#高效绘制甘特图" class="headerlink" title="高效绘制甘特图"></a>高效绘制甘特图</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">```gantt</span><br><span class="line">    title 项目开发流程</span><br><span class="line">    section 项目确定</span><br><span class="line">        需求分析       :a1, 2016-06-22, 3d</span><br><span class="line">        可行性报告     :after a1, 5d</span><br><span class="line">        概念验证       : 5d</span><br><span class="line">    section 项目实施</span><br><span class="line">        概要设计      :2016-07-05  , 5d</span><br><span class="line">        详细设计      :2016-07-08, 10d</span><br><span class="line">        编码          :2016-07-15, 10d</span><br><span class="line">        测试          :2016-07-22, 5d</span><br><span class="line">    section 发布验收</span><br><span class="line">        发布: 2d</span><br><span class="line">        验收: 3d</span><br></pre></td></tr></table></figure><p><img src="http://p3f66obex.bkt.clouddn.com/5-gantetu.JPG" alt=""></p><hr><h2 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h2><h3 id="开启公式支持"><a href="#开启公式支持" class="headerlink" title="开启公式支持"></a>开启公式支持</h3><p>Hexo 的自带的 Markdown 引擎并不支持 LaTeX 公式。 但是 MathJax 支持，因此首先要启用 MathJax 才能输入 LaTeX 公式。如果你已经安装了 NexT theme，开启 MathJax 非常容易，在 NexT 主题的 _config.yml 文件里，找到 MathJax 相关部分，使用以下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># MathJax Support</span><br><span class="line">mathjax:</span><br><span class="line">  enable: true</span><br><span class="line">  per_page: false</span><br><span class="line">  cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML</span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;align&#125;</span><br><span class="line">x &amp;= a + b + c + d\\\\</span><br><span class="line">  &amp;= e + f\\\\</span><br><span class="line">  &amp;= g</span><br><span class="line">\end&#123;align&#125;</span><br></pre></td></tr></table></figure><p>\begin{align}<br>x &amp;= a + b + c + d\\<br>  &amp;= e + f\\<br>  &amp;= g<br>\end{align}</p><blockquote><p>需要注意的是， LaTeX 公式编辑代码中与Hexo中特殊字符重合时，需要添加\符号进行转义</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;aligned&#125;</span><br><span class="line">f_Y(y) &amp; = f_X[h(y)]|h&apos;(y)| \\\\</span><br><span class="line">&amp; = f_X[h(y)]h&apos;(y) \\\\</span><br><span class="line">&amp; = \frac&#123;1&#125;&#123;\theta&#125;e^&#123;-\frac&#123;x&#125;&#123;\theta&#125;&#125;[\frac&#123;dx&#125;&#123;dy&#125;(-\frac&#123;\theta&#125;&#123;ln(1-y)&#125;)] \\\\</span><br><span class="line">&amp; = \frac&#123;1&#125;&#123;\theta&#125;e^&#123;-\frac&#123;-\frac&#123;\theta&#125;&#123;ln(1-y)&#125;&#125;&#123;\theta&#125;&#125;\frac&#123;\theta&#125;&#123;1-y&#125; \\\\</span><br><span class="line">&amp; = \frac&#123;1&#125;&#123;\theta&#125;e^&#123;ln(1-y)&#125;\frac&#123;\theta&#125;&#123;1-y&#125; \\\\</span><br><span class="line">&amp; = \frac&#123;1-y&#125;&#123;\theta&#125;\frac&#123;\theta&#125;&#123;1-y&#125; \\\\</span><br><span class="line">&amp; = 1 \\\\</span><br><span class="line">\end&#123;aligned&#125;</span><br></pre></td></tr></table></figure><p>\begin{aligned}<br>f_Y(y) &amp; = f_X[h(y)]|h’(y)| \\<br>&amp; = f_X[h(y)]h’(y) \\<br>&amp; = \frac{1}{\theta}e^{-\frac{x}{\theta}}[\frac{dx}{dy}(-\frac{\theta}{ln(1-y)})] \\<br>&amp; = \frac{1}{\theta}e^{-\frac{-\frac{\theta}{ln(1-y)}}{\theta}}\frac{\theta}{1-y} \\<br>&amp; = \frac{1}{\theta}e^{ln(1-y)}\frac{\theta}{1-y} \\<br>&amp; = \frac{1-y}{\theta}\frac{\theta}{1-y} \\<br>&amp; = 1 \\<br>\end{aligned}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Markdown&lt;/strong&gt;是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档。由于不同平台、网站Markdown引擎不完全相同，本文主要展示Hexo下的Markdown语法。&lt;
      
    
    </summary>
    
      <category term="博客" scheme="http://yoursite.com/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
      <category term="Markdown" scheme="http://yoursite.com/tags/Markdown/"/>
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>Scala实战--数值</title>
    <link href="http://yoursite.com/Scala%E5%AE%9E%E6%88%98--%E6%95%B0%E5%80%BC/"/>
    <id>http://yoursite.com/Scala实战--数值/</id>
    <published>2018-03-12T14:00:16.000Z</published>
    <updated>2018-04-05T11:06:02.041Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Scala所有的数值都是对象，包括Bytes、char、Double、Float、 Int、Long和Short。</p></blockquote><h2 id="从字符串到数值"><a href="#从字符串到数值" class="headerlink" title="从字符串到数值"></a>从字符串到数值</h2><p>使用String的to*方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;100&quot;.toInt</span><br><span class="line">&quot;100&quot;.toDouble</span><br><span class="line">&quot;100&quot;.toByte</span><br></pre></td></tr></table></figure><p>BigInt和BigDecimal也可以通过字符串创建：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val a = BigInt(&quot;1&quot;)</span><br><span class="line">val b = BigDecimal(&quot;3.1415926&quot;)</span><br></pre></td></tr></table></figure><p>处理基数和根，Scala中的toInt方法不支持传入进制，为解决这个问题，可以使用 java.lang.Integer类的parseInt方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer.parseInt(&quot;100&quot;,2)</span><br><span class="line">Integer.parseInt(&quot;100&quot;,8)</span><br><span class="line">Integer.parseInt(&quot;100&quot;,16)</span><br></pre></td></tr></table></figure><p>也可以通过隐式转换类的方法来解决这个问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">implicit class StringToInt(s: String)&#123;</span><br><span class="line">def toInt(radix: Int) = Integer.parseInt(s, radix)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&quot;100&quot;.toInt(2)</span><br></pre></td></tr></table></figure><p>处理NumberFormatException时，通常使用Option/Some/None模式来处理这类问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def toInt(s: String): Option[Int] = &#123;</span><br><span class="line">try&#123;</span><br><span class="line">Some(s.toInt)</span><br><span class="line">&#125;catch&#123;</span><br><span class="line">case e: NumberFormatException =&gt; None</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过getOrElse方法调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">println(toInt(&quot;1&quot;).getOrElse(0)) // 1</span><br><span class="line">println(toInt(&quot;a&quot;).getOrElse(0)) // 0</span><br></pre></td></tr></table></figure><p>或者通过模式匹配调用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">toInt(&quot;a&quot;) match&#123;</span><br><span class="line">case Some(n) =&gt; println(n)</span><br><span class="line">case None =&gt; println(&quot;Boom！That wasn&apos;t a number！&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 返回值</span><br><span class="line">var result = toInt(&quot;a&quot;) match&#123;</span><br><span class="line">case Some(n) =&gt; n</span><br><span class="line">case None =&gt; 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数值类型转换"><a href="#数值类型转换" class="headerlink" title="数值类型转换"></a>数值类型转换</h2><p>to*方法</p><h2 id="替代-和–"><a href="#替代-和–" class="headerlink" title="替代++和–"></a>替代++和–</h2><p>Scala中无++、–操作符，可用+=和-=替代。</p><h2 id="浮点数的比较"><a href="#浮点数的比较" class="headerlink" title="浮点数的比较"></a>浮点数的比较</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val a = 0.3 // 0.3</span><br><span class="line">val b = 0.1 + 0.2 // 0.30000000000000004</span><br><span class="line">a == b // False</span><br></pre></td></tr></table></figure><p>解决方法：自定义约等于方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">object MathUtils&#123;</span><br><span class="line">def ~=(x:Double, y:Double, precision:Double)&#123;</span><br><span class="line">if((x-y).abs &lt; peecision) true else false</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 静态方法调用</span><br><span class="line">MathUtils.~=(a, b, 0.000001)</span><br></pre></td></tr></table></figure><h2 id="成随机数"><a href="#成随机数" class="headerlink" title="成随机数"></a>成随机数</h2><p>使用Scala的Scala.util.random：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">val r = scala.util.random</span><br><span class="line">r.nextInt</span><br><span class="line">r.nextInt(100)</span><br><span class="line">r.nextDouble</span><br></pre></td></tr></table></figure><h2 id="生成区间数"><a href="#生成区间数" class="headerlink" title="生成区间数"></a>生成区间数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val a = 1 to 100 // [1, 100]</span><br><span class="line">val a = 1 until 100 // [1, 100)</span><br><span class="line">val a = 1 to 100 by 3  // 3为步长</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Scala所有的数值都是对象，包括Bytes、char、Double、Float、 Int、Long和Short。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;从字符串到数值&quot;&gt;&lt;a href=&quot;#从字符串到数值&quot; class=&quot;heade
      
    
    </summary>
    
      <category term="Scala" scheme="http://yoursite.com/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Scala实战--映射和元组</title>
    <link href="http://yoursite.com/Scala%E5%AE%9E%E6%88%98--%E6%98%A0%E5%B0%84%E5%92%8C%E5%85%83%E7%BB%84/"/>
    <id>http://yoursite.com/Scala实战--映射和元组/</id>
    <published>2018-03-05T14:00:16.000Z</published>
    <updated>2018-04-05T04:34:11.360Z</updated>
    
    <content type="html"><![CDATA[<h2 id="构建映射"><a href="#构建映射" class="headerlink" title="构建映射"></a>构建映射</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val scores = Map(&quot;Alice&quot; -&gt;10, &quot;Bob&quot; -&gt; 3, &quot;Clindy&quot; -&gt;8)</span><br></pre></td></tr></table></figure><p>上述代码构建的Map，其值不能被改变，构建可变映射，则用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val scores = scala.collection.mutable.Map&quot;Alice&quot; -&gt;10, &quot;Bob&quot; -&gt; 3, &quot;Clindy&quot; -&gt;8)</span><br></pre></td></tr></table></figure><p>也可用以下方式定义映射：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var scores = Map((&quot;Alice&quot;, 10), (&quot;Bob&quot;, 3), (&quot;Cindy&quot;, 8))</span><br></pre></td></tr></table></figure><h2 id="获取映射中的值"><a href="#获取映射中的值" class="headerlink" title="获取映射中的值"></a>获取映射中的值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val bobsScore = scores(&quot;Bob&quot;)</span><br><span class="line">// 类似于Java中的scores.get(&quot;Bob&quot;)</span><br><span class="line"></span><br><span class="line">// 检查映射中是否包含某键值，可用contions方法</span><br><span class="line">scores.contions(&quot;Bob&quot;)</span><br><span class="line">// return True</span><br><span class="line"></span><br><span class="line">val bobsScore = scores.getOrElse(&quot;Bob&quot;, 0)</span><br><span class="line">// 如果映射包含键&quot;Bob&quot;，返回对应的值；否则，返回0</span><br></pre></td></tr></table></figure><h2 id="更新映射中的值"><a href="#更新映射中的值" class="headerlink" title="更新映射中的值"></a>更新映射中的值</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scores(&quot;Bob&quot;) = 10 // scores必须为可变映射</span><br><span class="line">scores(&quot;Fred&quot;) = 7 //增加新的键并赋值</span><br><span class="line"></span><br><span class="line">// 可用+=操作来添加多个关系(不可变映射也可以)</span><br><span class="line">scores += (&quot;Bob&quot; -&gt; 10, &quot;Fred&quot; -&gt; 7)</span><br><span class="line"></span><br><span class="line">// 移除某个键，可用-=</span><br><span class="line">score -= &quot;Alice&quot;</span><br><span class="line"></span><br><span class="line">// 虽然不能更新不可变映射，但可是新建不可变映射的方法实现更新（曲线救国）</span><br><span class="line">var newScores = scores +  (&quot;Bob&quot; -&gt; 10, &quot;Fred&quot; -&gt; 7) // 更新过的新映射</span><br><span class="line">// newScores映射包含了与scores相同的映射关系，此外&quot;Bob&quot;被更新，&quot;Fred&quot;被添加进来</span><br></pre></td></tr></table></figure><p>除了把结果作为新值保存外，也可以直接更新var变量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var scores = ...</span><br><span class="line">scores = scores + (&quot;Bob&quot; -&gt; 10, &quot;Fred&quot; -&gt; 7)</span><br></pre></td></tr></table></figure><h2 id="迭代映射"><a href="#迭代映射" class="headerlink" title="迭代映射"></a>迭代映射</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for ((key, value) &lt;- Map)</span><br><span class="line">// 获取映射键集合</span><br><span class="line">scores.keySet</span><br><span class="line">// 获取映射值,return Iterable</span><br><span class="line">scores.values</span><br></pre></td></tr></table></figure><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>映射是键/值对偶的集合。对偶是元组（tuple）的最简单形态——元组是不同类型的值的聚集。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val t = (1, 3.14, &quot;Fred&quot;)</span><br><span class="line">// 可以用_1,_2,_3访问其组元</span><br><span class="line">val second = t._2 // 将second设为3.14,其中t._2也可写为t _2（.替换为空格）</span><br><span class="line">val (first, second, third) = t // 将first设为1，second设为3.14，third设为&quot;Fred&quot;</span><br><span class="line">val (first, second, _) = t  // 只返回部分</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;构建映射&quot;&gt;&lt;a href=&quot;#构建映射&quot; class=&quot;headerlink&quot; title=&quot;构建映射&quot;&gt;&lt;/a&gt;构建映射&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
      <category term="Scala" scheme="http://yoursite.com/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Scala实战--字符串</title>
    <link href="http://yoursite.com/Scala%E5%AE%9E%E6%88%98--%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://yoursite.com/Scala实战--字符串/</id>
    <published>2018-03-05T14:00:16.000Z</published>
    <updated>2018-04-05T10:50:12.619Z</updated>
    
    <content type="html"><![CDATA[<h2 id="测试字符串的相等性"><a href="#测试字符串的相等性" class="headerlink" title="测试字符串的相等性"></a>测试字符串的相等性</h2><h3 id="“-”方法"><a href="#“-”方法" class="headerlink" title="“==”方法"></a>“==”方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val s1 = &quot;Hello&quot;</span><br><span class="line">val s2 = &quot;Hello&quot;</span><br><span class="line">val s3 = &quot;H&quot; + &quot;ello&quot;</span><br><span class="line">s1 == s2 // return：True</span><br><span class="line">s2 == s3 // return：True</span><br></pre></td></tr></table></figure><h3 id="不考虑字符大小写"><a href="#不考虑字符大小写" class="headerlink" title="不考虑字符大小写"></a>不考虑字符大小写</h3><p>不考虑字符大小写的话，可以将比较字符串先统一转换成大写或小写，再进行”==”操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val s1 = &quot;hello&quot;</span><br><span class="line">val s2 = &quot;Hello&quot;</span><br><span class="line">s1.toUpperCase == s2.toUpperCase // return: True</span><br></pre></td></tr></table></figure><h3 id="equalsIngoreCase方法"><a href="#equalsIngoreCase方法" class="headerlink" title="equalsIngoreCase方法"></a>equalsIngoreCase方法</h3><p>也可以退而求其次，使用Java字符串类的equalsIngoreCase方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val s1 = &quot;hello&quot;</span><br><span class="line">val s2 = &quot;Hello&quot;</span><br><span class="line">s1.equalsIgnoreCase(s2) // return: True</span><br></pre></td></tr></table></figure><h2 id="创建多行字符串"><a href="#创建多行字符串" class="headerlink" title="创建多行字符串"></a>创建多行字符串</h2><p>在Scala中可以用3个双引号创建多行字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val foo = &quot;&quot;&quot;This is a</span><br><span class="line">             multiline</span><br><span class="line">             String&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h2 id="分隔字符串"><a href="#分隔字符串" class="headerlink" title="分隔字符串"></a>分隔字符串</h2><p>使用大名鼎鼎的split命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;Hello,World&quot;.split(&quot;,&quot;) // return： Array(Hello, World)</span><br></pre></td></tr></table></figure><p>split方法接受正则表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;hello world, this is Al&quot;.split(&quot;\\s+&quot;) // return: Array(hello, world, this, is, Al)</span><br></pre></td></tr></table></figure><p>分隔并实现各要素头尾空格的去除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;aaa, bbb,ccc, ddd &quot;.split(&quot;,&quot;).map(_.trim) // trim命令为去除字符串头尾空格</span><br></pre></td></tr></table></figure><p>进一步可以通过replaceAll的方法实现字符串要素中所有空格的去除：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;aa b,ccc , d d d&quot;.split(&quot;,&quot;) // return: Array(aa b,ccc , d d d)</span><br><span class="line">&quot;aa b,ccc , d d d&quot;.split(&quot;,&quot;).map(_.replaceAll(&quot; &quot;,&quot;&quot;)) // return: Array(aab,ccc,ddd)</span><br></pre></td></tr></table></figure><h2 id="字符串中的变量代换"><a href="#字符串中的变量代换" class="headerlink" title="字符串中的变量代换"></a>字符串中的变量代换</h2><p>本质上就是格式化字符串。</p><h3 id="字符串前加字母”s”，字符串中的变量前添加”-”"><a href="#字符串前加字母”s”，字符串中的变量前添加”-”" class="headerlink" title="字符串前加字母”s”，字符串中的变量前添加”$”"></a>字符串前加字母”s”，字符串中的变量前添加”$”</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val name = &quot;Tom&quot;</span><br><span class="line">val age = 18</span><br><span class="line">println(s&quot;$name is $age years old!&quot;) // return: Tom is 18 years old!</span><br></pre></td></tr></table></figure><p>在字符串中使用变量表达式时，需要用{}包裹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val age = 18</span><br><span class="line">println(s&quot;Age next year:$&#123;age + 1&#125;&quot;) // return: Age next year:19</span><br></pre></td></tr></table></figure><p>同时，访问对象的属性时，也要求用{}包裹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">case class Student(name:String, score:Int)</span><br><span class="line">val Tom = Student(&quot;Tom&quot;, 99)</span><br><span class="line">println(s&quot;$&#123;Tom.name&#125; has a score of $&#123;Tom.score&#125;&quot;)</span><br></pre></td></tr></table></figure><h3 id="字符串前加字母”f”，字符串中的变量前添加”-”，变量后添加”-”设置格式："><a href="#字符串前加字母”f”，字符串中的变量前添加”-”，变量后添加”-”设置格式：" class="headerlink" title="字符串前加字母”f”，字符串中的变量前添加”$”，变量后添加”%”设置格式："></a>字符串前加字母”f”，字符串中的变量前添加”$”，变量后添加”%”设置格式：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val name = &quot;Fred&quot;</span><br><span class="line">val weight = 200.00</span><br><span class="line">println(f&quot;$name weghts $weght%.0f pounds!&quot;)</span><br></pre></td></tr></table></figure><h3 id="format方法（类似于Python中的格式化字符串）"><a href="#format方法（类似于Python中的格式化字符串）" class="headerlink" title="format方法（类似于Python中的格式化字符串）"></a>format方法（类似于Python中的格式化字符串）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(&quot;%s is %d years old&quot;.format(name, age))</span><br></pre></td></tr></table></figure><p>printf的格式化常用符：</p><ul><li>%c：字符</li><li>%d：十进制数字</li><li>%e：指数浮点数</li><li>%f：浮点数</li><li>%i：整数（十进制）</li><li>%o：八进制数</li><li>%s：字符串</li><li>%u：无符号十进制数</li><li>%x：十六进制数</li><li>%%：打印一个百分号</li><li>\%：打印一个百分号</li></ul><p>去除转义，可在字符串前添加”raw”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">println(raw&quot;foo\nbar&quot;)</span><br></pre></td></tr></table></figure><h2 id="遍历字符串"><a href="#遍历字符串" class="headerlink" title="遍历字符串"></a>遍历字符串</h2><h3 id="map方法"><a href="#map方法" class="headerlink" title="map方法"></a>map方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val upper = &quot;hello, world&quot;.map(c =&gt; c.toUpper)</span><br><span class="line">val upper = &quot;hello, world&quot;.map(_.toUpper)</span><br><span class="line">// 与filter过滤器组合使用</span><br><span class="line">val upper = &quot;hello, world&quot;.filter(_ != &apos;l&apos;).map(_.toUpper)</span><br><span class="line">// 注意&apos;l&apos;为Char，而非String，故为单引号，双引号会报错</span><br></pre></td></tr></table></figure><h3 id="for…yield"><a href="#for…yield" class="headerlink" title="for…yield"></a>for…yield</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val upper = for (c &lt;- &quot;hello, world&quot;)yield c.toUpper</span><br></pre></td></tr></table></figure><p>在for循环添加yield实际上是将每次循环的结果放到临时存放区中，当循环结束的时候，在临时存放区中的所有元素以一个集合的形式返回，其作用与map方法等同。</p><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><p>循环打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;hello, world&quot;。foreach(println)</span><br></pre></td></tr></table></figure><h2 id="字符串中的查找模式"><a href="#字符串中的查找模式" class="headerlink" title="字符串中的查找模式"></a>字符串中的查找模式</h2><p>判断字符串是否符合某个正则表达式。</p><p>匹配数字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val numPattern = &quot;[0-9]+&quot;.r</span><br><span class="line">val address = &quot;123 Main Street Suite 101&quot;</span><br><span class="line">val match1 = numPattern.findFirstIn(address) // 第一个匹配的数字，返回：Option[String] = Some(123)</span><br><span class="line">val matchs = numPattern.findAllIn(address)  // 返回的迭代器</span><br><span class="line">val matchs = numPattern.findAllIn(address).toArray // 返回数组</span><br></pre></td></tr></table></figure><p>上面实例是通过字符串后面添加”.r”的方式创建正则表达式的，另外一种方式是引入Regex类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import scala.util.matching.Regex</span><br><span class="line">var numPattern = new Regex(&quot;[0-9]+&quot;)</span><br></pre></td></tr></table></figure><h2 id="抽取String中模式匹配的部分"><a href="#抽取String中模式匹配的部分" class="headerlink" title="抽取String中模式匹配的部分"></a>抽取String中模式匹配的部分</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 定义期望的模式</span><br><span class="line">val pattern = &quot;([0-9]+) ([A-Za-z]+)&quot;.r</span><br><span class="line">// 从目标字符串中提取正则组</span><br><span class="line">val pattern(count, fruit) = &quot;100 Bananas&quot;</span><br></pre></td></tr></table></figure><h2 id="访问字符串中的字符中的一个字符"><a href="#访问字符串中的字符中的一个字符" class="headerlink" title="访问字符串中的字符中的一个字符"></a>访问字符串中的字符中的一个字符</h2><h3 id="Java的charAt方法"><a href="#Java的charAt方法" class="headerlink" title="Java的charAt方法"></a>Java的charAt方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;hello&quot;.charAt(0)</span><br></pre></td></tr></table></figure><h3 id="Scala的数组方法"><a href="#Scala的数组方法" class="headerlink" title="Scala的数组方法"></a>Scala的数组方法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;hello&quot;(0)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;测试字符串的相等性&quot;&gt;&lt;a href=&quot;#测试字符串的相等性&quot; class=&quot;headerlink&quot; title=&quot;测试字符串的相等性&quot;&gt;&lt;/a&gt;测试字符串的相等性&lt;/h2&gt;&lt;h3 id=&quot;“-”方法&quot;&gt;&lt;a href=&quot;#“-”方法&quot; class=&quot;header
      
    
    </summary>
    
      <category term="Scala" scheme="http://yoursite.com/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
      <category term="编程" scheme="http://yoursite.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Scala实战--连接oracle及mysql数据库</title>
    <link href="http://yoursite.com/Scala%E5%AE%9E%E6%88%98--%E8%BF%9E%E6%8E%A5oracle%E5%8F%8Amysql%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>http://yoursite.com/Scala实战--连接oracle及mysql数据库/</id>
    <published>2018-03-01T14:00:16.000Z</published>
    <updated>2018-04-05T04:29:53.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="连接oracle数据库"><a href="#连接oracle数据库" class="headerlink" title="连接oracle数据库"></a>连接oracle数据库</h2><blockquote><p>Scala连接oracle数据库是通过Java的JDBC的方式实现的，具体实现方式如下：</p></blockquote><h2 id="在工程目录中添加oracle-jdbc的jar包"><a href="#在工程目录中添加oracle-jdbc的jar包" class="headerlink" title="在工程目录中添加oracle_jdbc的jar包"></a>在工程目录中添加oracle_jdbc的jar包</h2><p>‘build_path’-‘configure build path…’-‘libraries’-‘add exteral JARs’，添加oracle安装目录中的<strong>ojdbc6.jar</strong>包。</p><h2 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">import java.sql.Connection</span><br><span class="line">import java.sql.DriverManager</span><br><span class="line">import scala.collection.mutable.ArrayBuffer</span><br><span class="line"></span><br><span class="line">object get_oracle&#123;</span><br><span class="line">def main(args:Array[String])&#123;</span><br><span class="line">val url = &quot;jdbc:oracle:thin:@xx.x.xx.xxx:port/database&quot;</span><br><span class="line">// 驱动名称</span><br><span class="line">val = driver = &quot;oracle.jdbc.driver.OracleDriver&quot;</span><br><span class="line">// 用户名</span><br><span class="line">val username = &quot;********&quot;</span><br><span class="line">// 密码</span><br><span class="line">val password = &quot;********&quot;</span><br><span class="line">// 初始化数据连接</span><br><span class="line">val connection:Connection = null</span><br><span class="line">// 初始化查询结果</span><br><span class="line">val result = ArrayBuffer[String]()</span><br><span class="line">try&#123;</span><br><span class="line">// 注册Driver</span><br><span class="line">Class.forName(driver)</span><br><span class="line">println(&quot;开始尝试连接数据库&quot;)</span><br><span class="line">// 连接数据库</span><br><span class="line">connection = DriverManager.getConnection(url, username, password)</span><br><span class="line">println(&quot;数据库连接成功&quot;)</span><br><span class="line">// 初始化查询语句</span><br><span class="line">val statement = connection.createStatement</span><br><span class="line">// 执行查询结果，并返回结果</span><br><span class="line">val rs = statement.executeQuery(&quot;select t.* from test&quot;)</span><br><span class="line">// 打印返回结果</span><br><span class="line">var i = 1</span><br><span class="line">while(rs.next)&#123;</span><br><span class="line">val item = rs.getString(&quot;name&quot;)</span><br><span class="line">result.append(item)</span><br><span class="line">i = i + 1</span><br><span class="line">&#125;</span><br><span class="line">println(&quot;查询数据条数：&quot; + result.length)</span><br><span class="line">println(&quot;具体数据如下：&quot;)&#123;</span><br><span class="line">println(f&quot;第$&#123;i + 1&#125;条数据为：$&#123;result(i)&#125;&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">finally&#123;</span><br><span class="line">// connection.close</span><br><span class="line">println(&quot;数据查询成功&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="连接mysql数据库"><a href="#连接mysql数据库" class="headerlink" title="连接mysql数据库"></a>连接mysql数据库</h2><blockquote><p>连接MySQL数据库与oracle数据库类似，区别在于链接和驱动不一样，加载相应的mysql驱动的jar包即可。</p></blockquote><h2 id="与oracle的区别"><a href="#与oracle的区别" class="headerlink" title="与oracle的区别"></a>与oracle的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 不同于Oracle的部分</span><br><span class="line">val url = &quot;jdbc:mysql://localhost:3306/sys?useSSL=True&quot;  </span><br><span class="line">// useSSL=True主要是因为mysql在高版本中需要指明是否进行SSL连接</span><br><span class="line">var driver = com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure><h2 id="mysql驱动下载"><a href="#mysql驱动下载" class="headerlink" title="mysql驱动下载"></a>mysql驱动下载</h2><blockquote><p>mysql驱动下载地址为:<br><a href="https://dev.mysql.com/downloads/connector/j/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/connector/j/</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;连接oracle数据库&quot;&gt;&lt;a href=&quot;#连接oracle数据库&quot; class=&quot;headerlink&quot; title=&quot;连接oracle数据库&quot;&gt;&lt;/a&gt;连接oracle数据库&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Scala连接oracle数据库是通过Ja
      
    
    </summary>
    
      <category term="Scala" scheme="http://yoursite.com/categories/Scala/"/>
    
    
      <category term="Scala" scheme="http://yoursite.com/tags/Scala/"/>
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
